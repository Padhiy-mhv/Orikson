<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orikson — Галактическое Логово</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas { 
            display: block; 
            width: 100vw;
            height: 100vh;
        }
        .level-title {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6a5acd;
            font-size: 48px;
            text-shadow: 0 0 10px #9370db, 0 0 20px #483d8b;
            opacity: 1;
            transition: opacity 2s;
            z-index: 100;
            text-align: center;
        }
        .level-subtitle {
            font-size: 24px;
            display: block;
            margin-top: 10px;
            color: #9370db;
            text-shadow: 0 0 5px #483d8b;
        }
        .last-chance-btn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4b0082, #8a2be2);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 200;
            display: none;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.7);
            transition: all 0.3s ease;
        }
        .last-chance-btn:hover {
            background: linear-gradient(45deg, #8a2be2, #9932cc);
            box-shadow: 0 0 30px rgba(147, 112, 219, 0.9);
        }
        .glow-effect {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(147, 112, 219, 0.3) 0%, transparent 70%);
            filter: blur(30px);
            z-index: 5;
            display: none;
        }
        .explosion-effect {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.8) 0%, transparent 70%);
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        .dialog-box {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            max-width: 700px;
            background: rgba(40, 10, 60, 0.9);
            border: 2px solid #9370db;
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 16px;
            z-index: 100;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            min-height: 80px;
        }
        .dialog-text {
            margin-bottom: 10px;
            line-height: 1.4;
            min-height: 40px;
        }
        .dialog-name {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(147, 112, 219, 0.7);
        }
        .dialog-name.player {
            color: #ffffff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
        }
        .dialog-name.knight {
            color: #9370db;
            text-shadow: 0 0 5px rgba(147, 112, 219, 0.7);
        }
        .dialog-name.statue {
            color: #c0c0c0;
            text-shadow: 0 0 5px rgba(192, 192, 192, 0.7);
        }
        .next-btn {
            float: right;
            background: linear-gradient(45deg, #9370db, #8a2be2);
            border: none;
            color: white;
            padding: 6px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin-top: 5px;
        }
        .next-btn:hover {
            background: linear-gradient(45deg, #8a2be2, #9932cc);
            transform: scale(1.05);
        }
        .next-btn:active {
            transform: scale(0.95);
        }
        .typing-effect {
            border-right: 2px solid white;
            animation: blink 0.7s infinite;
        }
        .shield-effect {
            position: absolute;
            border-radius: 50%;
            background: rgba(100, 200, 255, 0.2);
            border: 2px solid rgba(100, 200, 255, 0.5);
            z-index: 5;
            display: none;
            pointer-events: none;
        }
        .boss-health-bar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(20, 10, 30, 0.7);
            border: 2px solid #9370db;
            border-radius: 5px;
            z-index: 100;
        }
        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #9370db);
            border-radius: 3px;
            transition: width 0.3s;
        }
        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 3px black;
        }
        .health-bar-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background: rgba(30, 10, 50, 0.7);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #4a148c;
            z-index: 100;
        }
        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffa500, #00ff00);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
        }
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
            pointer-events: none;
        }
        .transformation-timer {
            position: absolute;
            top: 55px;
            left: 20px;
            width: 200px;
            height: 10px;
            background: rgba(30, 10, 50, 0.7);
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #4a148c;
            z-index: 100;
            display: none;
        }
        .transformation-fill {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #0066cc);
            transition: width 0.3s ease;
        }
        @keyframes blink {
            0%, 100% { border-color: transparent; }
            50% { border-color: white; }
        }
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            z-index: 1;
            pointer-events: none;
        }
        .black-hole {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, #000000 0%, #4b0082 70%);
            z-index: 2;
            pointer-events: none;
        }
        .comet {
            position: absolute;
            z-index: 1;
            pointer-events: none;
        }
        .gravity-field {
            position: absolute;
            border-radius: 50%;
            z-index: 3;
            pointer-events: none;
        }
        .stun-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, transparent 70%);
            z-index: 15;
            display: none;
            pointer-events: none;
            filter: blur(5px);
        }
        .crack-effect {
            position: absolute;
            width: 200px;
            height: 100px;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transform: translate(-50%, -50%);
        }
        .warning-indicator {
            position: absolute;
            width: 100px;
            height: 30px;
            background: rgba(255, 0, 0, 0.5);
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            border-radius: 5px;
            transform: translate(-50%, 0);
            animation: pulse 0.5s infinite alternate;
        }
        @keyframes pulse {
            from { opacity: 0.3; }
            to { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="levelTitle" class="level-title">
        Галактическое Логово
        <span class="level-subtitle">Космический Страж</span>
    </div>
    <button id="lastChanceBtn" class="last-chance-btn">Последний шанс</button>
    <div id="playerGlow" class="glow-effect"></div>
    <div id="explosion" class="explosion-effect"></div>
    <div id="shield" class="shield-effect"></div>
    <div id="stunEffect" class="stun-effect"></div>
    <div id="dialogBox" class="dialog-box">
        <div id="dialogName" class="dialog-name"></div>
        <div id="dialogText" class="dialog-text"></div>
        <button id="nextBtn" class="next-btn">Далее</button>
    </div>
    <div id="bossHealthBar" class="boss-health-bar" style="display: none;">
        <div id="bossHealthFill" class="boss-health-fill"></div>
        <div id="bossHealthText" class="boss-health-text"></div>
    </div>
    <div id="healthBarContainer" class="health-bar-container">
        <div id="healthBar" class="health-bar"></div>
        <div id="healthText" class="health-text"></div>
    </div>
    <div id="transformationTimer" class="transformation-timer">
        <div id="transformationFill" class="transformation-fill"></div>
    </div>
    <div id="crackEffect" class="crack-effect"></div>
    <div id="warningIndicator" class="warning-indicator"></div>

    <script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script>
    <script>
        // ===== СИСТЕМА СОХРАНЕНИЯ HP И ПОСЛЕДНЕГО ШАНСА ===== //
        function initializeHealthSystem() {
            let currentHP = localStorage.getItem('currentHP');
            let lastChanceUsed = localStorage.getItem('lastChanceUsed');
            
            if (currentHP === null || currentHP === undefined || isNaN(parseInt(currentHP))) {
                localStorage.setItem('currentHP', '15');
                localStorage.setItem('lastChanceUsed', 'false');
            } else {
                if (parseInt(currentHP) <= 0) {
                    localStorage.setItem('currentHP', '15');
                    localStorage.setItem('lastChanceUsed', 'false');
                }
            }
            
            if (lastChanceUsed === null || lastChanceUsed === undefined) {
                localStorage.setItem('lastChanceUsed', 'false');
            }
        }

        function updateHP(change) {
            let currentHP = parseInt(localStorage.getItem('currentHP'));
            currentHP += change;
            
            if (currentHP < 0) currentHP = 0;
            if (currentHP > 15) currentHP = 15;
            
            localStorage.setItem('currentHP', currentHP.toString());
            updateHealthDisplay();
            
            return currentHP;
        }

        function getCurrentHP() {
            return parseInt(localStorage.getItem('currentHP'));
        }

        function isLastChanceUsed() {
            return localStorage.getItem('lastChanceUsed') === 'true';
        }

        function updateHealthDisplay() {
            const healthBar = document.getElementById('healthBar');
            const healthText = document.getElementById('healthText');
            const currentHP = player.health;
            const maxHP = player.maxHealth;
            
            const percent = (currentHP / maxHP) * 100;
            healthBar.style.width = `${percent}%`;
            healthText.textContent = `${currentHP}/${maxHP}`;
            
            if (percent < 30) {
                healthBar.style.background = 'linear-gradient(90deg, #ff0000, #8b0000)';
            } else if (percent < 60) {
                healthBar.style.background = 'linear-gradient(90deg, #ff0000, #ffa500)';
            } else {
                healthBar.style.background = 'linear-gradient(90deg, #ffa500, #00ff00)';
            }
        }

        function updateTransformationTimer() {
            const timerFill = document.getElementById('transformationFill');
            const percent = (player.transformationTimer / 240) * 100;
            timerFill.style.width = `${percent}%`;
        }

        // ===== ОСНОВНЫЕ НАСТРОЙКИ ===== //
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelTitle = document.getElementById('levelTitle');
        const lastChanceBtn = document.getElementById('lastChanceBtn');
        const playerGlow = document.getElementById('playerGlow');
        const explosion = document.getElementById('explosion');
        const shield = document.getElementById('shield');
        const stunEffect = document.getElementById('stunEffect');
        const dialogBox = document.getElementById('dialogBox');
        const dialogName = document.getElementById('dialogName');
        const dialogText = document.getElementById('dialogText');
        const nextBtn = document.getElementById('nextBtn');
        const bossHealthBar = document.getElementById('bossHealthBar');
        const bossHealthFill = document.getElementById('bossHealthFill');
        const bossHealthText = document.getElementById('bossHealthText');
        const crackEffect = document.getElementById('crackEffect');
        const warningIndicator = document.getElementById('warningIndicator');
        
        initializeHealthSystem();
        
        setTimeout(() => {
            levelTitle.style.opacity = '0';
            setTimeout(() => {
                levelTitle.style.display = 'none';
            }, 2000);
        }, 4000);
        
        const urlParams = new URLSearchParams(window.location.search);
        const initialHealth = parseInt(urlParams.get('health')) || getCurrentHP();
        
        const backgroundImage = new Image();
        backgroundImage.src = 'assets/images/space_boss.png';
        
        const groundTexture = new Image();
        groundTexture.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMxMDEwMzAiLz48cGF0aCBkPSJNMjAsMjAgQzMwLDEwIDQwLDMwIDMwLDQwIiBzdHJva2U9IiMyMDIwNjAiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik0xMCwxMCBDMjAsMCAzMCwyMCAyMCwzMCIgc3Ryb2tlPSIjMzAzMDkwIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiLz48L3N2Zz4=';
        
        const platformTexture = new Image();
        platformTexture.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDUwIDIwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iMjAiIGZpbGw9IiMyMDIwNjAiLz48cGF0aCBkPSJNMCwxMCBDMTUsNSAzMCwxNSA1MCwxMCIgc3Ryb2tlPSIjMzAzMDkwIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiLz48L3N2Zz4=';

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            groundLevel = canvas.height * 0.8;
        }
        window.addEventListener('resize', resizeCanvas);
        
        let groundLevel;
        resizeCanvas();
        
        // ===== ПЕРСОНАЖ ===== //
        const player = {
            x: 100,
            y: groundLevel - 70,
            width: 50,
            height: 70,
            knightWidth: 120,
            knightHeight: 150,
            knightOffsetY: 30,
            velocityX: 0,
            velocityY: 0,
            facingRight: true,
            isJumping: false,
            isAttacking: false,
            attackCooldown: 0,
            health: initialHealth,
            maxHealth: 15,
            animation: null,
            animator: null,
            currentAnimation: 'idle',
            invincible: false,
            invincibleTimer: 0,
            onGround: false,
            isDead: false,
            deathTimer: 0,
            canTeleport: false,
            deathAnimationPlayed: false,
            transformed: false,
            transformationTimer: 0,
            attackRange: 70,
            knightAttackRange: 150,
            damage: 1,
            knightDamage: 3,
            jumpForce: 15,
            knightJumpForce: 14,
            speed: 5,
            knightSpeed: 4,
            currentPlatform: null,
            hasShieldAbility: false,
            isBlocking: false,
            blockCooldown: 0,
            dashCooldown: 0,
            isDashing: false,
            dashTimer: 0,
            isStunned: false,
            stunTimer: 0
        };

        // ===== БОСС - КОСМИЧЕСКИЙ СТРАЖ ===== //
        const boss = {
            x: canvas.width * 0.5,
            y: groundLevel - 220,
            width: 280,
            height: 300,
            speed: 2,
            direction: -1,
            health: 45,
            maxHealth: 45,
            minX: 50,
            maxX: canvas.width - 50,
            minY: 50,
            maxY: groundLevel - 50,
            animation: null,
            attackAnimation: null,
            hurtAnimation: null,
            deathAnimation: null,
            animator: null,
            isAttacking: false,
            isHurt: false,
            isDead: false,
            attackCooldown: 0,
            damage: 2,
            attackRange: 120,
            attackYRange: 100,
            hurtTimer: 0,
            deathTimer: 0,
            idleTimer: 0,
            isIdle: false,
            phase: 1,
            lastPlatformSpawn: 0,
            platformSpawnCooldown: 10000,
            attackDelay: 400,
            isAttackConnected: false,
            lastDash: 0,
            dashCooldown: 3000,
            isDashing: false,
            dashTargetX: 0,
            dashTargetY: 0,
            dashSpeed: 10,
            lastStarAttack: 0,
            starAttackCooldown: 5000,
            isStarAttacking: false,
            stars: [],
            lastGravityAttack: 0,
            gravityAttackCooldown: 8000,
            isGravityAttacking: false,
            gravityFields: [],
            lastTeleport: 0,
            teleportCooldown: 10000,
            isTeleporting: false,
            lastShadowStrike: 0,
            shadowStrikeCooldown: 15000,
            isUnderground: false,
            shadowStrikeTargetX: 0,
            shadowStrikeTargetY: 0
        };

        // ===== АНИМАЦИИ ===== //
        const playerAnimations = { 
            idle: null, 
            walk: null, 
            jump: null,
            attack: null,
            hurt: null,
            death: null,
            knightIdle: null,
            knightWalk: null,
            knightAttack: null,
            knightJump: null,
            animators: {
                idle: null,
                walk: null,
                jump: null,
                attack: null,
                hurt: null,
                death: null,
                knightIdle: null,
                knightWalk: null,
                knightAttack: null,
                knightJump: null
            }
        };

        const bossAnimations = {
            idle: null,
            walk: null,
            attack: null,
            hurt: null,
            death: null,
            dash: null,
            starAttack: null,
            gravityAttack: null,
            teleport: null,
            animators: {
                idle: null,
                walk: null,
                attack: null,
                hurt: null,
                death: null,
                dash: null,
                starAttack: null,
                gravityAttack: null,
                teleport: null
            }
        };

        // ===== СТАТУЯ ===== //
        const statue = {
            x: canvas.width * 0.1,
            y: groundLevel - 200,
            width: 80,
            height: 200,
            animation: null,
            animator: null,
            active: true
        };

        // ===== ИСТОЧНИК ЖИЗНИ ===== //
        const healthSource = {
            x: 0,
            y: 0,
            width: 40,
            height: 60,
            animation: null,
            animator: null,
            active: false,
            used: false,
            timer: 0,
            duration: 7000,
            spawnPattern: 0
        };

        // ===== ВРЕМЕННЫЕ ПЛАТФОРМЫ ===== //
        const tempPlatforms = [];
        
        // ===== ЗВЕЗДЫ И КОМЕТЫ ===== //
        const stars = [];
        const blackHoles = [];
        const comets = [];
        
        function createStars() {
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5 + 0.5,
                    alpha: Math.random() * 0.8 + 0.2,
                    speed: Math.random() * 0.05 + 0.05
                });
            }
            
            for (let i = 0; i < 3; i++) {
                blackHoles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.5,
                    radius: Math.random() * 50 + 30,
                    rotation: 0,
                    rotationSpeed: Math.random() * 0.01 - 0.005
                });
            }
        }
        
        function createComet() {
            comets.push({
                x: Math.random() * canvas.width,
                y: -50,
                speedX: (Math.random() - 0.5) * 2,
                speedY: Math.random() * 3 + 2,
                size: Math.random() * 10 + 5,
                alpha: 1,
                tail: []
            });
        }
        
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            
            blackHoles.forEach(hole => {
                hole.rotation += hole.rotationSpeed;
            });
            
            for (let i = comets.length - 1; i >= 0; i--) {
                const comet = comets[i];
                comet.x += comet.speedX;
                comet.y += comet.speedY;
                
                comet.tail.push({x: comet.x, y: comet.y});
                if (comet.tail.length > 20) {
                    comet.tail.shift();
                }
                
                if (comet.y > canvas.height + 100 || comet.x < -100 || comet.x > canvas.width + 100) {
                    comets.splice(i, 1);
                }
            }
            
            if (Math.random() < 0.01) {
                createComet();
            }
        }
        
        function drawStars() {
            stars.forEach(star => {
                ctx.save();
                ctx.globalAlpha = star.alpha;
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            blackHoles.forEach(hole => {
                ctx.save();
                ctx.translate(hole.x, hole.y);
                ctx.rotate(hole.rotation);
                
                const gradient = ctx.createRadialGradient(0, 0, hole.radius * 0.5, 0, 0, hole.radius);
                gradient.addColorStop(0, 'rgba(75, 0, 130, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, hole.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(0, 0, hole.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.7)';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(0, 0, hole.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            });
            
            comets.forEach(comet => {
                ctx.save();
                for (let i = 0; i < comet.tail.length; i++) {
                    const point = comet.tail[i];
                    const progress = i / comet.tail.length;
                    ctx.globalAlpha = progress * comet.alpha;
                    ctx.fillStyle = `rgba(100, 200, 255, ${progress})`;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, comet.size * progress, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });
        }

        // ===== ТЕНЕВОЙ ПРОРЫВ ===== //
        function shadowStrike() {
            if (boss.isUnderground || boss.isDead || boss.isHurt) return;
            
            const now = Date.now();
            if (now - boss.lastShadowStrike < boss.shadowStrikeCooldown) return;
            
            boss.lastShadowStrike = now;
            boss.isUnderground = true;
            boss.animation = bossAnimations.teleport;
            boss.animator = bossAnimations.animators.teleport;
            
            // Запоминаем позицию игрока для атаки
            boss.shadowStrikeTargetX = player.x + (player.transformed ? player.knightWidth/2 : player.width/2);
            boss.shadowStrikeTargetY = player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2);
            
            // Показываем предупреждающий индикатор
            warningIndicator.style.left = `${boss.shadowStrikeTargetX}px`;
            warningIndicator.style.top = `${groundLevel - 15}px`;
            warningIndicator.style.width = '150px';
            warningIndicator.style.opacity = '0.5';
            
            // Анимация мерцания земли
            let flashCount = 0;
            const maxFlashes = 6;
            const flashInterval = setInterval(() => {
                warningIndicator.style.opacity = flashCount % 2 === 0 ? '0.7' : '0.3';
                flashCount++;
                
                if (flashCount >= maxFlashes) {
                    clearInterval(flashInterval);
                    warningIndicator.style.opacity = '0';
                }
            }, 200);
            
            // Исчезает под землей
            setTimeout(() => {
                // Создаем трещины перед появлением
                createGroundCracks(boss.shadowStrikeTargetX, groundLevel);
                
                // Появляется снизу
                setTimeout(() => {
                    boss.x = boss.shadowStrikeTargetX - boss.width/2;
                    boss.y = groundLevel - 50; // Появляется снизу, но не опускается ниже минимальной Y-координаты
                    
                    // Визуальные эффекты взрыва
                    explosion.style.display = 'block';
                    explosion.style.left = `${boss.shadowStrikeTargetX}px`;
                    explosion.style.top = `${groundLevel}px`;
                    explosion.style.opacity = '0.8';
                    
                    explosion.animate(
                        [
                            { transform: 'scale(0.5)', opacity: 0 },
                            { transform: 'scale(1)', opacity: 0.8 },
                            { transform: 'scale(1.5)', opacity: 0 }
                        ],
                        {
                            duration: 500,
                            easing: 'ease-out'
                        }
                    ).onfinish = () => {
                        explosion.style.display = 'none';
                    };
                    
                    // Удар после задержки
                    setTimeout(() => {
                        boss.y = Math.max(boss.minY, groundLevel - boss.height); // Проверка на минимальную Y-координату
                        boss.isUnderground = false;
                        boss.animation = bossAnimations.attack;
                        boss.animator = bossAnimations.animators.attack;
                        
                        // Проверка попадания по игроку
                        if (Math.abs(player.x + (player.transformed ? player.knightWidth/2 : player.width/2) - boss.shadowStrikeTargetX) < 100 && 
                            !player.invincible && !player.isDead) {
                            
                            let damage = 3; // Увеличенный урон для этой атаки
                            
                            if (player.isBlocking) {
                                damage = Math.floor(damage * 0.5);
                                
                                ctx.save();
                                ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
                                ctx.beginPath();
                                ctx.arc(
                                    player.x + (player.transformed ? player.knightWidth/2 : player.width/2), 
                                    player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2), 
                                    60, 
                                    0, 
                                    Math.PI * 2
                                );
                                ctx.fill();
                                ctx.restore();
                            }
                            
                            player.health -= damage;
                            updateHP(-damage);
                            
                            if (player.health <= 0) {
                                playerDie();
                            } else {
                                playerHurt(boss);
                            }
                        }
                    }, 300);
                }, 500);
            }, 2000);
        }

        function createGroundCracks(x, y) {
            crackEffect.style.left = `${x}px`;
            crackEffect.style.top = `${y}px`;
            crackEffect.style.opacity = '1';
            crackEffect.style.background = 'radial-gradient(circle, transparent 0%, rgba(138, 43, 226, 0.3) 70%)';
            
            // Анимация трещин
            crackEffect.animate(
                [
                    { transform: 'scale(0.5)', opacity: 0 },
                    { transform: 'scale(1)', opacity: 0.8 },
                    { transform: 'scale(1.2)', opacity: 0 }
                ],
                {
                    duration: 800,
                    easing: 'ease-out'
                }
            ).onfinish = () => {
                crackEffect.style.opacity = '0';
            };
            
            // Рисуем трещины на canvas
            ctx.save();
            ctx.strokeStyle = 'rgba(147, 112, 219, 0.7)';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const length = Math.random() * 50 + 30;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // ===== ГРАВИТАЦИОННАЯ АТАКА ===== //
        function bossGravityAttack() {
            if (boss.isGravityAttacking || boss.isDead || boss.isHurt) return;
            
            const now = Date.now();
            if (now - boss.lastGravityAttack < boss.gravityAttackCooldown) return;
            
            boss.lastGravityAttack = now;
            boss.isGravityAttacking = true;
            boss.animation = bossAnimations.gravityAttack;
            boss.animator = bossAnimations.animators.gravityAttack;
            
            const gravityField = {
                x: player.x + (Math.random() - 0.5) * 200,
                y: player.y + (Math.random() - 0.5) * 100,
                radius: 180,
                power: 0.9,
                timer: 150,
                active: true,
                stunApplied: false,
                pullStrength: 0.05
            };
            
            boss.gravityFields.push(gravityField);
            
            const animateGravity = () => {
                if (gravityField.timer > 0) {
                    gravityField.timer--;
                    
                    if (!player.invincible && !player.isDead && !player.isStunned) {
                        const dx = gravityField.x - (player.x + (player.transformed ? player.knightWidth/2 : player.width/2));
                        const dy = gravityField.y - (player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2));
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < gravityField.radius) {
                            const force = gravityField.power * (1 - distance/gravityField.radius);
                            player.x += dx * gravityField.pullStrength * force;
                            player.y += dy * gravityField.pullStrength * force;
                            
                            if (distance < 40 && gravityField.timer % 10 === 0) {
                                player.health -= 1;
                                updateHP(-1);
                                
                                if (player.health <= 0) {
                                    playerDie();
                                }
                            }
                            
                            if (gravityField.timer <= 15 && !gravityField.stunApplied) {
                                gravityField.stunApplied = true;
                                stunPlayer(gravityField.x, gravityField.y);
                            }
                        }
                    }
                    
                    requestAnimationFrame(animateGravity);
                } else {
                    const index = boss.gravityFields.indexOf(gravityField);
                    if (index !== -1) {
                        boss.gravityFields.splice(index, 1);
                    }
                }
            };
            
            animateGravity();
            
            setTimeout(() => {
                boss.isGravityAttacking = false;
                if (!boss.isHurt && !boss.isDead) {
                    boss.animation = bossAnimations.walk;
                    boss.animator = bossAnimations.animators.walk;
                }
            }, 2500);
        }

        function stunPlayer(x, y) {
            player.isStunned = true;
            player.stunTimer = 150;
            
            stunEffect.style.display = 'block';
            stunEffect.style.left = `${x - 50}px`;
            stunEffect.style.top = `${y - 50}px`;
            
            stunEffect.animate(
                [
                    { transform: 'scale(0.5)', opacity: 0 },
                    { transform: 'scale(1)', opacity: 0.8 },
                    { transform: 'scale(1.2)', opacity: 0 }
                ],
                {
                    duration: 500,
                    iterations: 1
                }
            );
            
            setTimeout(() => {
                if (!boss.isDead && !boss.isHurt) {
                    boss.x = player.x - 50;
                    boss.y = player.y - 50;
                    
                    setTimeout(() => {
                        if (!player.invincible && !player.isDead) {
                            player.health -= 4;
                            updateHP(-4);
                            
                            if (player.health <= 0) {
                                playerDie();
                            } else {
                                playerHurt(boss);
                            }
                        }
                    }, 300);
                }
            }, 500);
            
            setTimeout(() => {
                player.isStunned = false;
                stunEffect.style.display = 'none';
            }, 2500);
        }

        // ===== ТЕЛЕПОРТАЦИЯ БОССА ===== //
        function bossTeleport() {
            if (boss.isTeleporting || boss.isDead || boss.isHurt) return;
            
            const now = Date.now();
            if (now - boss.lastTeleport < boss.teleportCooldown) return;
            
            boss.lastTeleport = now;
            boss.isTeleporting = true;
            boss.animation = bossAnimations.teleport;
            boss.animator = bossAnimations.animators.teleport;
            
            setTimeout(() => {
                const newX = player.x + (Math.random() - 0.5) * 300;
                const newY = Math.max(boss.minY, Math.min(boss.maxY, player.y - 150 + (Math.random() - 0.5) * 100));
                
                boss.x = Math.max(50, Math.min(canvas.width - 50 - boss.width, newX));
                boss.y = newY;
                
                setTimeout(() => {
                    boss.isTeleporting = false;
                    if (!boss.isHurt && !boss.isDead) {
                        boss.animation = bossAnimations.walk;
                        boss.animator = bossAnimations.animators.walk;
                    }
                    
                    setTimeout(() => {
                        if (!boss.isDead && !boss.isHurt) {
                            boss.isAttacking = true;
                            boss.isAttackConnected = false;
                            boss.animation = bossAnimations.attack;
                            boss.animator = bossAnimations.animators.attack;
                            boss.attackCooldown = 120;
                            
                            setTimeout(() => {
                                const distanceX = Math.abs((player.x + (player.transformed ? player.knightWidth/2 : player.width/2)) - (boss.x + boss.width/2));
                                const distanceY = Math.abs((player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2)) - (boss.y + boss.height/2));
                                const isInRangeX = distanceX < boss.attackRange;
                                const isInRangeY = distanceY < boss.attackYRange;
                                
                                if (isInRangeX && isInRangeY && !player.invincible && !player.isDead && !boss.isAttackConnected) {
                                    let damage = boss.damage;
                                    
                                    if (player.isBlocking) {
                                        damage = Math.floor(damage * 0.5);
                                        
                                        ctx.save();
                                        ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
                                        ctx.beginPath();
                                        ctx.arc(
                                            player.x + (player.transformed ? player.knightWidth/2 : player.width/2), 
                                            player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2), 
                                            60, 
                                            0, 
                                            Math.PI * 2
                                        );
                                        ctx.fill();
                                        ctx.restore();
                                    }
                                    
                                    player.health -= damage;
                                    updateHP(-damage);
                                    boss.isAttackConnected = true;
                                    
                                    if (player.health <= 0) {
                                        playerDie();
                                    } else {
                                        playerHurt(boss);
                                    }
                                }
                            }, boss.attackDelay);
                            
                            setTimeout(() => {
                                boss.isAttacking = false;
                                if (!boss.isHurt && !boss.isDead) {
                                    boss.animation = bossAnimations.walk;
                                    boss.animator = bossAnimations.animators.walk;
                                }
                            }, 800);
                        }
                    }, 300);
                }, 500);
            }, 500);
        }

        // ===== КОСМИЧЕСКИЙ ФОН ===== //
        function drawSpaceBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000033');
            gradient.addColorStop(0.5, '#000066');
            gradient.addColorStop(1, '#000011');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.globalAlpha = 0.3;
            
            ctx.fillStyle = 'rgba(75, 0, 130, 0.3)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.3, canvas.height * 0.2, 300, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(0, 0, 139, 0.3)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.7, canvas.height * 0.4, 250, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            ctx.save();
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = 'rgba(138, 43, 226, 0.2)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.8, canvas.height * 0.1, 150, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // ===== ПЛАТФОРМЫ ===== //
        function drawPlatforms() {
            platforms.forEach(platform => {
                if (platform.type === 'ground' && groundTexture.complete) {
                    const pattern = ctx.createPattern(groundTexture, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    ctx.strokeStyle = 'rgba(147, 112, 219, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, platform.y);
                    ctx.lineTo(canvas.width, platform.y);
                    ctx.stroke();
                } 
                else if (platform.type === 'platform' && platformTexture.complete) {
                    const pattern = ctx.createPattern(platformTexture, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(platform.x, platform.y + platform.height, platform.width, 5);
                    
                    ctx.strokeStyle = 'rgba(147, 112, 219, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                }
                else if (platform.type === 'wall') {
                    ctx.fillStyle = '#101030';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                }
            });
            
            tempPlatforms.forEach(platform => {
                if (platformTexture.complete) {
                    ctx.save();
                    ctx.globalAlpha = platform.alpha;
                    const pattern = ctx.createPattern(platformTexture, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(platform.x, platform.y + platform.height, platform.width, 3);
                    
                    ctx.strokeStyle = 'rgba(147, 112, 219, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                    ctx.restore();
                }
            });
        }

        // ===== СТАТУЯ ===== //
        function drawStatue() {
            if (!statue.active || !statue.animation) return;
            
            ctx.save();
            ctx.drawImage(
                statue.animation,
                statue.x - statue.width/2,
                statue.y - statue.height,
                statue.width,
                statue.height
            );
            
            const lightX = statue.x;
            const lightY = statue.y - statue.height * 0.7;
            
            const gradient = ctx.createRadialGradient(
                lightX, lightY, 10,
                lightX, lightY, 100
            );
            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(lightX, lightY, 100, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // ===== ИСТОЧНИК ЖИЗНИ ===== //
        function drawHealthSource() {
            if (!healthSource.active || healthSource.used || !healthSource.animation) return;
            
            ctx.save();
            ctx.globalAlpha = healthSource.alpha;
            ctx.drawImage(
                healthSource.animation,
                healthSource.x - healthSource.width/2,
                healthSource.y - healthSource.height,
                healthSource.width,
                healthSource.height
            );
            
            const lightX = healthSource.x;
            const lightY = healthSource.y - healthSource.height * 0.7;
            
            const gradient = ctx.createRadialGradient(
                lightX, lightY, 10,
                lightX, lightY, 60
            );
            gradient.addColorStop(0, 'rgba(100, 255, 100, 0.3)');
            gradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(lightX, lightY, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            if (Math.abs(player.x - healthSource.x) < 50 && 
                Math.abs(player.y - healthSource.y) < 80 &&
                !healthSource.used && player.health < player.maxHealth) {
                
                healthSource.used = true;
                player.health = Math.min(player.health + 5, player.maxHealth);
                updateHP(5);
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const particle = {
                            x: healthSource.x,
                            y: healthSource.y - healthSource.height,
                            radius: Math.random() * 5 + 2,
                            speedX: (Math.random() - 0.5) * 3,
                            speedY: -Math.random() * 3 - 1,
                            alpha: 1,
                            color: '#00ff00'
                        };
                        
                        const animateParticle = () => {
                            particle.x += particle.speedX;
                            particle.y += particle.speedY;
                            particle.alpha -= 0.02;
                            
                            if (particle.alpha > 0) {
                                ctx.save();
                                ctx.globalAlpha = particle.alpha;
                                ctx.fillStyle = particle.color;
                                ctx.beginPath();
                                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                                requestAnimationFrame(animateParticle);
                            }
                        };
                        
                        animateParticle();
                    }, i * 50);
                }
            }
        }

        // ===== ЩИТ ===== //
        function drawShield() {
            if (!player.isBlocking || player.isDead) return;
            
            const shieldSize = player.transformed ? 100 : 80;
            shield.style.width = `${shieldSize}px`;
            shield.style.height = `${shieldSize}px`;
            shield.style.left = `${player.x + (player.transformed ? player.knightWidth/2 : player.width/2) - shieldSize/2}px`;
            shield.style.top = `${player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2) - shieldSize/2}px`;
            shield.style.display = 'block';
        }

        // ===== ЗДОРОВЬЕ БОССА ===== //
        function drawBossHealth() {
            if (!bossActive || boss.isDead) {
                bossHealthBar.style.display = 'none';
                return;
            }
            
            bossHealthBar.style.display = 'block';
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            bossHealthFill.style.width = `${healthPercent}%`;
            bossHealthText.textContent = `${boss.health}/${boss.maxHealth}`;
            
            if (healthPercent < 30) {
                bossHealthFill.style.background = 'linear-gradient(90deg, #8a2be2, #4b0082)';
            } else if (healthPercent < 60) {
                bossHealthFill.style.background = 'linear-gradient(90deg, #9370db, #8a2be2)';
            } else {
                bossHealthFill.style.background = 'linear-gradient(90deg, #9370db, #9932cc)';
            }
        }

        // ===== ВРЕМЕННЫЕ ПЛАТФОРМЫ ===== //
        function spawnTempPlatforms() {
            if (!bossActive || boss.isDead || boss.isHurt) return;
            
            const now = Date.now();
            if (now - boss.lastPlatformSpawn < boss.platformSpawnCooldown) return;
            
            boss.lastPlatformSpawn = now;
            tempPlatforms.length = 0;
            healthSource.active = false;
            
            healthSource.spawnPattern = Math.random() > 0.75 ? 1 : 0;
            
            if (healthSource.spawnPattern === 0) {
                const side = Math.random() > 0.5 ? 'left' : 'right';
                let startX, direction;
                
                if (side === 'left') {
                    startX = canvas.width * 0.1;
                    direction = 1;
                } else {
                    startX = canvas.width * 0.7;
                    direction = -1;
                }
                
                const platformWidth = canvas.width * 0.15;
                const platformHeight = 20;
                const platformSpacing = canvas.width * 0.05;
                
                for (let i = 0; i < 3; i++) {
                    const x = startX + (i * (platformWidth + platformSpacing)) * direction;
                    const y = groundLevel - 150 - (i * 80);
                    
                    tempPlatforms.push({
                        x: x,
                        y: y,
                        width: platformWidth,
                        height: platformHeight,
                        alpha: 0,
                        targetAlpha: 1,
                        timer: 0,
                        duration: 1000
                    });
                    
                    if (i === 1 && Math.random() < 0.25) {
                        healthSource.x = x + platformWidth/2;
                        healthSource.y = y;
                        healthSource.active = true;
                        healthSource.used = false;
                        healthSource.alpha = 0;
                        healthSource.timer = 0;
                    }
                }
            } else {
                const platformWidth = canvas.width * 0.12;
                const platformHeight = 15;
                
                tempPlatforms.push({
                    x: canvas.width * 0.1,
                    y: groundLevel - 100,
                    width: platformWidth,
                    height: platformHeight,
                    alpha: 0,
                    targetAlpha: 1,
                    timer: 0,
                    duration: 1000
                });
                
                tempPlatforms.push({
                    x: canvas.width * 0.7,
                    y: groundLevel - 180,
                    width: platformWidth,
                    height: platformHeight,
                    alpha: 0,
                    targetAlpha: 1,
                    timer: 0,
                    duration: 1000
                });
                
                tempPlatforms.push({
                    x: canvas.width * 0.2,
                    y: groundLevel - 260,
                    width: platformWidth,
                    height: platformHeight,
                    alpha: 0,
                    targetAlpha: 1,
                    timer: 0,
                    duration: 1000
                });
                
                if (Math.random() < 0.25) {
                    healthSource.x = canvas.width * 0.2 + platformWidth/2;
                    healthSource.y = groundLevel - 260;
                    healthSource.active = true;
                    healthSource.used = false;
                    healthSource.alpha = 0;
                    healthSource.timer = 0;
                }
            }
        }

        function updateTempPlatforms() {
            const now = Date.now();
            
            tempPlatforms.forEach(platform => {
                if (platform.timer < platform.duration) {
                    platform.timer += 16;
                    platform.alpha = platform.targetAlpha * (platform.timer / platform.duration);
                }
                
                if (now - boss.lastPlatformSpawn > boss.platformSpawnCooldown - 1000) {
                    platform.targetAlpha = 0;
                    platform.timer = Math.max(0, platform.timer - 16);
                    platform.alpha = platform.targetAlpha * (1 - (boss.platformSpawnCooldown - (now - boss.lastPlatformSpawn)) / 1000);
                }
            });
            
            if (healthSource.active) {
                if (healthSource.timer < healthSource.duration) {
                    healthSource.timer += 16;
                    
                    if (!healthSource.used) {
                        healthSource.alpha = Math.min(1, healthSource.timer / 500);
                    }
                }
                
                if (now - boss.lastPlatformSpawn > boss.platformSpawnCooldown - 1000) {
                    healthSource.alpha = Math.max(0, 1 - (boss.platformSpawnCooldown - (now - boss.lastPlatformSpawn)) / 1000);
                    
                    if (healthSource.alpha <= 0) {
                        healthSource.active = false;
                    }
                }
            }
            
            if (tempPlatforms.length > 0 && tempPlatforms[0].alpha <= 0) {
                tempPlatforms.shift();
            }
        }

        // ===== АТАКА ЗВЕЗДАМИ ===== //
        function bossStarAttack() {
            if (boss.isStarAttacking || boss.isDead || boss.isHurt) return;
            
            const now = Date.now();
            if (now - boss.lastStarAttack < boss.starAttackCooldown) return;
            
            boss.lastStarAttack = now;
            boss.isStarAttacking = true;
            boss.animation = bossAnimations.starAttack;
            boss.animator = bossAnimations.animators.starAttack;
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const star = {
                        x: boss.x + boss.width/2,
                        y: boss.y + boss.height/2,
                        radius: 15,
                        speedX: (Math.random() - 0.5) * 5,
                        speedY: -Math.random() * 5 - 3,
                        damage: 1,
                        alpha: 1,
                        color: `hsl(${Math.random() * 60 + 270}, 100%, 50%)`
                    };
                    
                    boss.stars.push(star);
                    
                    const animateStar = () => {
                        star.x += star.speedX;
                        star.y += star.speedY;
                        star.speedY += 0.1;
                        
                        if (!player.invincible && !player.isDead && !player.isDashing) {
                            const playerCenterX = player.x + (player.transformed ? player.knightWidth/2 : player.width/2);
                            const playerCenterY = player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2);
                            
                            const distance = Math.sqrt(
                                Math.pow(star.x - playerCenterX, 2) + 
                                Math.pow(star.y - playerCenterY, 2)
                            );
                            
                            if (distance < star.radius + (player.transformed ? 40 : 30)) {
                                player.health -= star.damage;
                                updateHP(-star.damage);
                                star.alpha = 0;
                                
                                if (player.health <= 0) {
                                    playerDie();
                                } else {
                                    playerHurt(boss);
                                }
                            }
                        }
                        
                        if (star.y > canvas.height || star.x < 0 || star.x > canvas.width) {
                            const index = boss.stars.indexOf(star);
                            if (index !== -1) {
                                boss.stars.splice(index, 1);
                            }
                            return;
                        }
                        
                        requestAnimationFrame(animateStar);
                    };
                    
                    animateStar();
                }, i * 300);
            }
            
            setTimeout(() => {
                boss.isStarAttacking = false;
                if (!boss.isHurt && !boss.isDead) {
                    boss.animation = bossAnimations.walk;
                    boss.animator = bossAnimations.animators.walk;
                }
            }, 3000);
        }

        // ===== РЫВОК БОССА ===== //
        function bossDash() {
            if (boss.isDashing || boss.isDead || boss.isHurt) return;
            
            const now = Date.now();
            if (now - boss.lastDash < boss.dashCooldown) return;
            
            boss.lastDash = now;
            boss.isDashing = true;
            boss.animation = bossAnimations.dash;
            boss.animator = bossAnimations.animators.dash;
            
            boss.dashTargetX = player.x + (player.facingRight ? -100 : 100);
            boss.dashTargetY = Math.max(boss.minY, Math.min(boss.maxY, player.y));
            
            boss.dashTargetX = Math.max(50, Math.min(canvas.width - 50 - boss.width, boss.dashTargetX));
            
            const dx = boss.dashTargetX - boss.x;
            const dy = boss.dashTargetY - boss.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const directionX = dx / distance;
            const directionY = dy / distance;
            
            const dashInterval = setInterval(() => {
                boss.x += directionX * boss.dashSpeed;
                boss.y += directionY * boss.dashSpeed;
                
                const remainingDistance = Math.sqrt(
                    Math.pow(boss.dashTargetX - boss.x, 2) + 
                    Math.pow(boss.dashTargetY - boss.y, 2)
                );
                
                if (remainingDistance < 10) {
                    clearInterval(dashInterval);
                    boss.isDashing = false;
                    
                    if (!boss.isHurt && !boss.isDead) {
                        boss.animation = bossAnimations.walk;
                        boss.animator = bossAnimations.animators.walk;
                    }
                }
            }, 16);
        }

        // ===== ОБНОВЛЕНИЕ БОССА ===== //
        function updateBoss() {
            if (boss.isDead) {
                boss.deathTimer--;
                if (boss.deathTimer <= 0) {
                    currentDialogs = bossDeathDialogs;
                    currentDialog = 0;
                    gameState = 'dialog';
                    showNextDialog();
                }
                return;
            } else if (boss.health <= 0) {
                boss.isDead = true;
                boss.deathTimer = 120;
                boss.animation = bossAnimations.death;
                boss.animator = bossAnimations.animators.death;
                return;
            }

            if (boss.isHurt) {
                boss.hurtTimer--;
                if (boss.hurtTimer <= 0) {
                    boss.isHurt = false;
                    boss.animation = bossAnimations.walk;
                    boss.animator = bossAnimations.animators.walk;
                }
            }

            if (boss.attackCooldown > 0) {
                boss.attackCooldown--;
            }

            if (boss.isIdle) {
                boss.idleTimer--;
                if (boss.idleTimer <= 0) {
                    boss.isIdle = false;
                    boss.animation = bossAnimations.walk;
                    boss.animator = bossAnimations.animators.walk;
                }
            } else if (Math.random() < 0.005 && !boss.isAttacking && !boss.isHurt) {
                boss.isIdle = true;
                boss.idleTimer = Math.random() * 60 + 30;
                boss.animation = bossAnimations.idle;
                boss.animator = bossAnimations.animators.idle;
            }

            if (!boss.isIdle && !boss.isAttacking && !boss.isHurt && !boss.isDead && !boss.isDashing && !boss.isTeleporting && !boss.isUnderground) {
                if (boss.phase === 2) {
                    const moveX = (Math.random() - 0.5) * boss.speed * 2;
                    const moveY = (Math.random() - 0.5) * boss.speed * 2;
                    
                    boss.x += moveX;
                    boss.y += moveY;
                    
                    boss.x = Math.max(50, Math.min(canvas.width - 50 - boss.width, boss.x));
                    boss.y = Math.max(boss.minY, Math.min(boss.maxY, boss.y));
                    
                    if (moveX > 0) boss.direction = 1;
                    else if (moveX < 0) boss.direction = -1;
                } else {
                    boss.x += boss.speed * boss.direction;
                    
                    if (boss.x <= boss.minX || boss.x + boss.width >= boss.maxX) {
                        boss.direction *= -1;
                    }
                }
                
                if (boss.health < boss.maxHealth * 0.6) {
                    boss.phase = 2;
                    boss.platformSpawnCooldown = 7000;
                    
                    if (Math.random() < 0.01) {
                        bossDash();
                    }
                    
                    if (Math.random() < 0.008) {
                        bossStarAttack();
                    }
                    
                    if (Math.random() < 0.006) {
                        bossGravityAttack();
                    }
                    
                    if (Math.random() < 0.005) {
                        bossTeleport();
                    }
                    
                    if (Math.random() < 0.004) {
                        shadowStrike();
                    }
                }
                
                spawnTempPlatforms();
            }

            checkBossAttack();
        }

        // ===== ПРОВЕРКА АТАКИ БОССА ===== //
        function checkBossAttack() {
            if (player.isDead || player.invincible || boss.isDashing || player.isStunned || boss.isTeleporting || boss.isUnderground) return;
            
            const distanceX = Math.abs((player.x + (player.transformed ? player.knightWidth/2 : player.width/2)) - (boss.x + boss.width/2));
            const distanceY = Math.abs((player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2)) - (boss.y + boss.height/2));
            const isInRangeX = distanceX < boss.attackRange;
            const isInRangeY = distanceY < boss.attackYRange;
            
            const isFacingPlayer = (boss.direction < 0 && player.x < boss.x) || 
                                 (boss.direction > 0 && player.x > boss.x);
            
            if (isInRangeX && isInRangeY && isFacingPlayer && 
                boss.attackCooldown <= 0 && !boss.isHurt && !boss.isDead && !boss.isStarAttacking) {
                
                boss.isAttacking = true;
                boss.isAttackConnected = false;
                boss.animation = bossAnimations.attack;
                boss.animator = bossAnimations.animators.attack;
                boss.attackCooldown = 120;
                
                setTimeout(() => {
                    if (isInRangeX && isInRangeY && !player.invincible && !player.isDead && !boss.isAttackConnected) {
                        let damage = boss.damage;
                        
                        if (player.isBlocking) {
                            damage = Math.floor(damage * 0.5);
                            
                            ctx.save();
                            ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
                            ctx.beginPath();
                            ctx.arc(
                                player.x + (player.transformed ? player.knightWidth/2 : player.width/2), 
                                player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2), 
                                60, 
                                0, 
                                Math.PI * 2
                            );
                            ctx.fill();
                            ctx.restore();
                        }
                        
                        player.health -= damage;
                        updateHP(-damage);
                        boss.isAttackConnected = true;
                        
                        if (player.health <= 0) {
                            playerDie();
                        } else {
                            playerHurt(boss);
                        }
                    }
                }, boss.attackDelay);
                
                setTimeout(() => {
                    boss.isAttacking = false;
                    if (!boss.isHurt && !boss.isDead) {
                        boss.animation = bossAnimations.walk;
                        boss.animator = bossAnimations.animators.walk;
                    }
                }, 800);
            }
        }

        // ===== ФИЗИКА ИГРОКА ===== //
        function updatePlayerPhysics() {
            if (player.isDead && !player.transformed) return;

            if (player.attackCooldown > 0) {
                player.attackCooldown--;
            }

            if (player.blockCooldown > 0) {
                player.blockCooldown--;
            }
            
            if (player.dashCooldown > 0) {
                player.dashCooldown--;
            }
            
            if (player.isStunned) {
                player.stunTimer--;
                if (player.stunTimer <= 0) {
                    player.isStunned = false;
                }
                return;
            }

            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                    if (!player.isJumping && !player.isAttacking && !player.isBlocking && !player.isDashing) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                }
            }

            if (player.transformed) {
                player.transformationTimer--;
                updateTransformationTimer();
                
                if (player.transformationTimer <= 0) {
                    endTransformation();
                }
            }
            
            if (player.isDashing) {
                player.dashTimer--;
                if (player.dashTimer <= 0) {
                    player.isDashing = false;
                    player.invincible = false;
                    
                    if (!player.isJumping && !player.isAttacking && !player.isBlocking) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                } else {
                    const dashSpeed = player.transformed ? 12 : 15;
                    player.x += player.facingRight ? dashSpeed : -dashSpeed;
                    
                    const playerWidth = player.transformed ? player.knightWidth : player.width;
                    if (player.x < 20) player.x = 20;
                    if (player.x + playerWidth > canvas.width - 20) player.x = canvas.width - 20 - playerWidth;
                    
                    return;
                }
            }

            player.velocityY += 0.5;
            player.y += player.velocityY;
            player.onGround = false;
            player.currentPlatform = null;

            platforms.forEach(platform => {
                const playerBottom = player.transformed ? 
                    (player.y + player.knightHeight - player.knightOffsetY) : 
                    (player.y + player.height);
                
                const playerWidth = player.transformed ? player.knightWidth : player.width;
                const playerHeight = player.transformed ? player.knightHeight : player.height;
                
                if (
                    playerBottom >= platform.y &&
                    playerBottom <= platform.y + 20 &&
                    player.x + playerWidth > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.velocityY >= 0
                ) {
                    player.y = platform.y - (player.transformed ? player.knightHeight - player.knightOffsetY : player.height);
                    player.velocityY = 0;
                    player.isJumping = false;
                    player.onGround = true;
                    player.currentPlatform = platform;
                    
                    if (!player.isAttacking && !player.invincible && !player.isDead && !player.isBlocking && !player.isDashing && !player.isStunned) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                }
            });
            
            tempPlatforms.forEach(platform => {
                if (platform.alpha <= 0) return;
                
                const playerBottom = player.transformed ? 
                    (player.y + player.knightHeight - player.knightOffsetY) : 
                    (player.y + player.height);
                
                const playerWidth = player.transformed ? player.knightWidth : player.width;
                const playerHeight = player.transformed ? player.knightHeight : player.height;
                
                if (
                    playerBottom >= platform.y &&
                    playerBottom <= platform.y + 20 &&
                    player.x + playerWidth > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.velocityY >= 0
                ) {
                    player.y = platform.y - (player.transformed ? player.knightHeight - player.knightOffsetY : player.height);
                    player.velocityY = 0;
                    player.isJumping = false;
                    player.onGround = true;
                    player.currentPlatform = platform;
                    
                    if (!player.isAttacking && !player.invincible && !player.isDead && !player.isBlocking && !player.isDashing && !player.isStunned) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                }
            });

            if (!player.isAttacking && !player.invincible && !player.isDead && !player.isBlocking && !player.isDashing && !player.isStunned) {
                const speed = player.transformed ? player.knightSpeed : player.speed;
                
                if (keys['a'] || keys['arrowleft']) {
                    player.velocityX = -speed;
                    player.facingRight = false;
                    if (player.onGround) {
                        player.currentAnimation = player.transformed ? 'knightWalk' : 'walk';
                        player.animation = player.transformed ? playerAnimations.knightWalk : playerAnimations.walk;
                        player.animator = player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk;
                    }
                } else if (keys['d'] || keys['arrowright']) {
                    player.velocityX = speed;
                    player.facingRight = true;
                    if (player.onGround) {
                        player.currentAnimation = player.transformed ? 'knightWalk' : 'walk';
                        player.animation = player.transformed ? playerAnimations.knightWalk : playerAnimations.walk;
                        player.animator = player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk;
                    }
                } else {
                    player.velocityX = 0;
                    if (player.onGround && !player.isJumping) {
                        player.currentAnimation = player.transformed ? 'knightIdle' : 'idle';
                        player.animation = player.transformed ? playerAnimations.knightIdle : playerAnimations.idle;
                        player.animator = player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle;
                    }
                }
            } else {
                player.velocityX *= 0.9;
            }

            player.x += player.velocityX;

            const playerWidth = player.transformed ? player.knightWidth : player.width;
            if (player.x < 20) player.x = 20;
            if (player.x + playerWidth > canvas.width - 20) player.x = canvas.width - 20 - playerWidth;
        }

        // ===== УПРАВЛЕНИЕ ===== //
        const keys = {};
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            if (player.isDead && !player.transformed || player.isStunned) return;
            
            if ((key === 'w' || key === 'arrowup') && !player.isJumping && player.onGround) {
                player.isJumping = true;
                const jumpForce = player.transformed ? player.knightJumpForce : player.jumpForce;
                player.velocityY = -jumpForce;
                player.currentAnimation = player.transformed ? 'knightJump' : 'jump';
                player.animation = player.transformed ? playerAnimations.knightJump : playerAnimations.jump;
                player.animator = player.transformed ? playerAnimations.animators.knightJump : playerAnimations.animators.jump;
            }
            
            if (key === 'f' && !player.isAttacking && player.attackCooldown <= 0 && !player.isBlocking && !player.isDashing) {
                player.isAttacking = true;
                player.currentAnimation = player.transformed ? 'knightAttack' : 'attack';
                player.animation = player.transformed ? playerAnimations.knightAttack : playerAnimations.attack;
                player.animator = player.transformed ? playerAnimations.animators.knightAttack : playerAnimations.animators.attack;
                player.attackCooldown = player.transformed ? 40 : 30;
                
                setTimeout(() => {
                    player.isAttacking = false;
                    if (!player.isJumping && !player.isDead && !player.isBlocking && !player.isDashing) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                }, player.transformed ? 600 : 500);
                
                setTimeout(() => {
                    checkPlayerAttack();
                }, player.transformed ? 300 : 200);
            }
            
            if (key === 'q' && player.hasShieldAbility && !player.isAttacking && player.blockCooldown <= 0 && !player.isDashing) {
                player.isBlocking = true;
                drawShield();
            }
            
            if (key === 'shift' && !player.isDashing && player.dashCooldown <= 0 && !player.isBlocking) {
                player.isDashing = true;
                player.dashTimer = 15;
                player.dashCooldown = 60;
                player.invincible = true;
                
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const particle = {
                            x: player.x + (player.transformed ? player.knightWidth/2 : player.width/2),
                            y: player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2),
                            radius: Math.random() * 5 + 2,
                            speedX: (player.facingRight ? -1 : 1) * (Math.random() * 3 + 2),
                            speedY: (Math.random() - 0.5) * 4,
                            alpha: 1,
                            color: `hsl(${Math.random() * 60 + 240}, 100%, 50%)`
                        };
                        
                        const animateParticle = () => {
                            particle.x += particle.speedX;
                            particle.y += particle.speedY;
                            particle.alpha -= 0.05;
                            
                            if (particle.alpha > 0) {
                                ctx.save();
                                ctx.globalAlpha = particle.alpha;
                                ctx.fillStyle = particle.color;
                                ctx.beginPath();
                                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                                requestAnimationFrame(animateParticle);
                            }
                        };
                        
                        animateParticle();
                    }, i * 50);
                }
            }

            if ((key === 'enter' || key === ' ') && gameState === 'dialog') {
                handleNextDialog();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
            
            if (key === 'q' && player.isBlocking) {
                player.isBlocking = false;
                shield.style.display = 'none';
                player.blockCooldown = 30;
            }
        });

        // ===== АТАКА ИГРОКА ===== //
        function checkPlayerAttack() {
            if (!player.isAttacking || player.isDead || player.isStunned) return;

            const attackRange = player.transformed ? player.knightAttackRange : player.attackRange;
            const damage = player.transformed ? player.knightDamage : player.damage;
            
            if (bossActive && !boss.isDead) {
                const playerAttackX = player.facingRight ? 
                    player.x + (player.transformed ? player.knightWidth : player.width) : 
                    player.x;
                    
                const bossX = boss.x + boss.width/2;
                const distanceX = Math.abs(playerAttackX - bossX);
                
                const playerY = player.transformed ? 
                    player.y - player.knightOffsetY + player.knightHeight/2 : 
                    player.y + player.height/2;
                    
                const bossY = boss.y + boss.height/2;
                const distanceY = Math.abs(playerY - bossY);
                
                const isInRangeX = distanceX < attackRange;
                const isInRangeY = distanceY < 100;
                
                if (isInRangeX && isInRangeY) {
                    boss.health -= damage;
                    
                    if (boss.health <= 0) {
                        boss.isDead = true;
                        boss.deathTimer = 120;
                        boss.animation = bossAnimations.death;
                        boss.animator = bossAnimations.animators.death;
                    } else {
                        boss.isHurt = true;
                        boss.hurtTimer = 30;
                        boss.animation = bossAnimations.hurt;
                        boss.animator = bossAnimations.animators.hurt;
                        
                        boss.velocityX = (player.facingRight ? 1 : -1) * 5;
                    }
                }
            }
        }

        function playerHurt(enemy) {
            player.invincible = true;
            player.invincibleTimer = 60;
            player.currentAnimation = player.transformed ? 'knightIdle' : 'hurt';
            player.animation = player.transformed ? playerAnimations.knightIdle : playerAnimations.hurt;
            player.animator = player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.hurt;
            
            player.velocityX = (player.x < enemy.x ? -1 : 1) * (player.transformed ? 6 : 8);
            player.velocityY = player.transformed ? -4 : -6;
        }

        function playerDie() {
            player.isDead = true;
            player.currentAnimation = player.transformed ? 'knightIdle' : 'death';
            player.animation = player.transformed ? playerAnimations.knightIdle : playerAnimations.death;
            player.animator = player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.death;
            
            if (!isLastChanceUsed()) {
                setTimeout(() => {
                    showLastChance();
                }, 2000);
            }
        }

        function showLastChance() {
            lastChanceBtn.style.display = 'block';
        }

        lastChanceBtn.addEventListener('click', () => {
            lastChanceBtn.style.display = 'none';
            localStorage.setItem('lastChanceUsed', 'true');
            transformToKnight();
        });

        function transformToKnight() {
            player.isDead = false;
            player.transformed = true;
            player.transformationTimer = 240;
            player.health = Math.floor(player.maxHealth / 2);
            updateHP(Math.floor(player.maxHealth / 2) - player.health);
            player.invincible = true;
            
            document.getElementById('transformationTimer').style.display = 'block';
            
            if (player.currentPlatform) {
                player.y = player.currentPlatform.y - (player.knightHeight - player.knightOffsetY);
            } else if (player.onGround) {
                player.y = groundLevel - (player.knightHeight - player.knightOffsetY);
            }
            
            playerGlow.style.display = 'block';
            playerGlow.style.left = `${player.x - 150}px`;
            playerGlow.style.top = `${player.y - 150}px`;
            
            const glowAnimation = playerGlow.animate(
                [
                    { transform: 'scale(1)', opacity: 0.7 },
                    { transform: 'scale(1.2)', opacity: 0.3 },
                    { transform: 'scale(1)', opacity: 0.7 }
                ],
                {
                    duration: 1000,
                    iterations: Infinity
                }
            );
            
            setTimeout(() => {
                glowAnimation.cancel();
                playerGlow.style.display = 'none';
            }, 1000);
            
            explosion.style.display = 'block';
            explosion.style.left = `${player.x + (player.transformed ? player.knightWidth/2 : player.width/2)}px`;
            explosion.style.top = `${player.y + (player.transformed ? player.knightHeight/2 : player.height/2)}px`;
            explosion.style.opacity = '0.8';
            
            explosion.animate(
                [
                    { transform: 'scale(0.5)', opacity: 0 },
                    { transform: 'scale(1)', opacity: 0.8 },
                    { transform: 'scale(1.5)', opacity: 0 }
                ],
                {
                    duration: 1000,
                    easing: 'ease-out'
                }
            ).onfinish = () => {
                explosion.style.display = 'none';
            };
            
            player.currentAnimation = 'knightIdle';
            player.animation = playerAnimations.knightIdle;
            player.animator = playerAnimations.animators.knightIdle;
            
            updateHealthDisplay();
        }

        function endTransformation() {
            player.transformed = false;
            player.invincible = false;
            document.getElementById('transformationTimer').style.display = 'none';
            
            if (player.currentPlatform) {
                player.y = player.currentPlatform.y - player.height;
            } else if (player.onGround) {
                player.y = groundLevel - player.height;
            }
            
            explosion.style.display = 'block';
            explosion.style.left = `${player.x + player.width/2}px`;
            explosion.style.top = `${player.y + player.height/2}px`;
            explosion.style.opacity = '0.8';
            
            explosion.animate(
                [
                    { transform: 'scale(0.5)', opacity: 0 },
                    { transform: 'scale(1)', opacity: 0.8 },
                    { transform: 'scale(1.5)', opacity: 0 }
                ],
                {
                    duration: 1000,
                    easing: 'ease-out'
                }
            ).onfinish = () => {
                explosion.style.display = 'none';
            };
            
            player.currentAnimation = 'idle';
            player.animation = playerAnimations.idle;
            player.animator = playerAnimations.animators.idle;
            
            updateHealthDisplay();
            
            if (player.health <= 0) {
                player.isDead = true;
                player.currentAnimation = 'death';
                player.animation = playerAnimations.death;
                player.animator = playerAnimations.animators.death;
            }
        }

        // ===== ДИАЛОГИ ===== //
        const initialDialogs = [
            { type: 'knight', text: 'Мы достигли логова Космического Стража - хранителя звездных врат.' },
            { type: 'knight', text: 'Он контролирует потоки энергии между измерениями и не позволит нам пройти без боя.' },
            { type: 'player', text: 'Это место... оно кажется таким древним и полным силы. Звезды здесь выглядят иначе...' },
            { type: 'knight', text: 'Да, это пространство между мирами. Будь осторожен, гравитация здесь работает по-другому.' },
            { type: 'statue', text: 'Путник... Я - древний страж звездных врат. Часть моего сознания попала в тебя через источник жизни.' },
            { type: 'statue', text: 'Я дарую тебе способность к короткому рывку в пространстве. Нажми Shift, чтобы совершить рывок.' },
            { type: 'statue', text: 'Рывок делает тебя неуязвимым на короткое время и позволяет избегать атак.' },
            { type: 'statue', text: 'А также я буду создавать для тебя платформы с источником жизни, но их расположение будет меняться.' },
            { type: 'knight', text: 'Он пробуждается! Готовься к бою!' },
            { type: 'end-dialog' }
        ];

        const bossDeathDialogs = [
            { type: 'knight', text: 'Ты сделал это! Космический Страж повержен!' },
            { type: 'knight', text: 'Звездные врата теперь открыты... но что-то не так.' },
            { type: 'player', text: 'Пространство искажается... Кажется, мы разбудили что-то большее...' },
            { type: 'knight', text: 'Это... не может быть. Пробуждается Древний Пожиратель Миров!' },
            { type: 'knight', text: 'Нам нужно срочно пройти через врата, пока пространство не схлопнулось!' },
            { type: 'end-dialog' }
        ];
        
        let currentDialogs = initialDialogs;
        let currentDialog = 0;
        let isTyping = false;
        let currentText = '';
        let currentIndex = 0;
        let typingSpeed = 20;
        let gameState = 'dialog';
        let bossActive = false;
        let time = 0;

        function typeText() {
            if (currentIndex < currentText.length) {
                dialogText.innerHTML = currentText.substring(0, currentIndex + 1) + '<span class="typing-effect"></span>';
                currentIndex++;
                setTimeout(typeText, typingSpeed);
            } else {
                dialogText.innerHTML = currentText;
                isTyping = false;
                nextBtn.style.display = 'block';
            }
        }

        function showNextDialog() {
            if (currentDialog >= currentDialogs.length) {
                endDialogSequence();
                return;
            }
            
            const dialog = currentDialogs[currentDialog];
            
            if (dialog.type === 'end-dialog') {
                endDialogSequence();
                return;
            }
            
            dialogBox.style.display = 'block';
            nextBtn.style.display = 'none';
            
            if (dialog.type === 'player') {
                dialogName.textContent = 'Игрок';
                dialogName.className = 'dialog-name player';
                dialogText.style.color = '#ffffff';
            } 
            else if (dialog.type === 'knight') {
                dialogName.textContent = 'Рыцарь';
                dialogName.className = 'dialog-name knight';
                dialogText.style.color = '#9370db';
            }
            else if (dialog.type === 'statue') {
                dialogName.textContent = 'Древний Страж';
                dialogName.className = 'dialog-name statue';
                dialogText.style.color = '#c0c0c0';
            }
            
            currentText = dialog.text;
            currentIndex = 0;
            isTyping = true;
            typeText();
        }

        function handleNextDialog() {
            if (isTyping) {
                currentIndex = currentText.length;
                dialogText.innerHTML = currentText;
                isTyping = false;
                nextBtn.style.display = 'block';
            } else {
                currentDialog++;
                showNextDialog();
            }
        }

        nextBtn.addEventListener('click', handleNextDialog);

        function endDialogSequence() {
            dialogBox.style.display = 'none';
            gameState = 'gameplay';
            
            if (currentDialogs === initialDialogs) {
                bossActive = true;
                player.hasShieldAbility = true;
            }
        }

        // ===== ЗАГРУЗКА АНИМАЦИЙ ===== //
        function loadGIF(path, animationName, target) {
            const bufferCanvas = document.createElement('canvas');
            
            if (target === 'boss') {
                bufferCanvas.width = 180;
                bufferCanvas.height = 220;
            } else if (target === 'statue') {
                bufferCanvas.width = 80;
                bufferCanvas.height = 200;
            } else if (target === 'healthSource') {
                bufferCanvas.width = 40;
                bufferCanvas.height = 60;
            } else {
                bufferCanvas.width = 50;
                bufferCanvas.height = 70;
            }

            gifler(path).get((anim) => {
                anim.animateInCanvas(bufferCanvas);
                
                if (target === 'player') {
                    playerAnimations[animationName] = bufferCanvas;
                    playerAnimations.animators[animationName] = anim;
                    
                    if (animationName === 'idle' && !player.animation) {
                        player.animation = playerAnimations.idle;
                        player.animator = playerAnimations.animators.idle;
                        player.currentAnimation = 'idle';
                    }
                } else if (target === 'boss') {
                    bossAnimations[animationName] = bufferCanvas;
                    bossAnimations.animators[animationName] = anim;
                    
                    if (animationName === 'idle') {
                        boss.animation = bossAnimations.idle;
                        boss.animator = bossAnimations.animators.idle;
                    }
                } else if (target === 'statue') {
                    statue.animation = bufferCanvas;
                    statue.animator = anim;
                } else if (target === 'healthSource') {
                    healthSource.animation = bufferCanvas;
                    healthSource.animator = anim;
                }
            });
        }

        // Загружаем анимации
        loadGIF('assets/images/player_idle.gif', 'idle', 'player');
        loadGIF('assets/images/player_walk.gif', 'walk', 'player');
        loadGIF('assets/images/player_jump.gif', 'jump', 'player');
        loadGIF('assets/images/player_attack.gif', 'attack', 'player');
        loadGIF('assets/images/player_hurt.gif', 'hurt', 'player');
        loadGIF('assets/images/player_death.gif', 'death', 'player');
        loadGIF('assets/images/knight_idle.gif', 'knightIdle', 'player');
        loadGIF('assets/images/knight_walk.gif', 'knightWalk', 'player');
        loadGIF('assets/images/knight_attack.gif', 'knightAttack', 'player');
        loadGIF('assets/images/knight_jump.gif', 'knightJump', 'player');

        loadGIF('assets/images/space_boss_idle.gif', 'idle', 'boss');
        loadGIF('assets/images/space_boss_walk.gif', 'walk', 'boss');
        loadGIF('assets/images/space_boss_attack.gif', 'attack', 'boss');
        loadGIF('assets/images/space_boss_hurt.gif', 'hurt', 'boss');
        loadGIF('assets/images/space_boss_death.gif', 'death', 'boss');
        loadGIF('assets/images/space_boss_dash.gif', 'dash', 'boss');
        loadGIF('assets/images/space_boss_star_attack.gif', 'starAttack', 'boss');
        loadGIF('assets/images/space_boss_gravity_attack.gif', 'gravityAttack', 'boss');
        loadGIF('assets/images/space_boss_teleport.gif', 'teleport', 'boss');

        loadGIF('assets/images/space_statue.gif', 'statue', 'statue');
        loadGIF('assets/images/health_source.gif', 'healthSource', 'healthSource');

        // ===== ПЛАТФОРМЫ ===== //
        const platforms = [
            { x: 0, y: groundLevel, width: canvas.width, height: canvas.height - groundLevel, type: 'ground' },
            { x: 0, y: 0, width: 20, height: groundLevel, type: 'wall' },
            { x: canvas.width - 20, y: 0, width: 20, height: groundLevel, type: 'wall' }
        ];

        // ===== ОСНОВНОЙ ЦИКЛ ИГРЫ ===== //
        function gameLoop() {
            time += 16;
            
            if (gameState !== 'dialog') {
                updatePlayerPhysics();
                updateTempPlatforms();
                
                if (bossActive) {
                    updateBoss();
                }
                
                updateStars();
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawSpaceBackground();
            drawStars();
            drawPlatforms();
            drawStatue();
            drawHealthSource();
            
            boss.gravityFields.forEach(field => {
                const gradient = ctx.createRadialGradient(
                    field.x, field.y, 0,
                    field.x, field.y, field.radius
                );
                gradient.addColorStop(0, 'rgba(138, 43, 226, 0.1)');
                gradient.addColorStop(0.7, 'rgba(75, 0, 130, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.save();
                ctx.globalAlpha = 0.5 * (field.timer / 150);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(field.x, field.y, field.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(147, 112, 219, 0.7)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(field.x, field.y, field.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
            
            boss.stars.forEach(star => {
                ctx.save();
                ctx.globalAlpha = star.alpha;
                ctx.fillStyle = star.color;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
                
                const glow = ctx.createRadialGradient(
                    star.x, star.y, 0,
                    star.x, star.y, star.radius * 3
                );
                glow.addColorStop(0, star.color);
                glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.globalAlpha = star.alpha * 0.3;
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius * 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            if (bossActive && boss.animation) {
                ctx.save();
                if (boss.x > player.x) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(boss.animation, -boss.x - boss.width, boss.y, boss.width, boss.height);
                } else {
                    ctx.drawImage(boss.animation, boss.x, boss.y, boss.width, boss.height);
                }
                
                if (boss.isStarAttacking || boss.isDashing || boss.isGravityAttacking || boss.isTeleporting || boss.isUnderground) {
                    const glow = ctx.createRadialGradient(
                        boss.x + boss.width/2, 
                        boss.y + boss.height/2, 
                        0,
                        boss.x + boss.width/2, 
                        boss.y + boss.height/2, 
                        150
                    );
                    glow.addColorStop(0, 'rgba(138, 43, 226, 0.8)');
                    glow.addColorStop(1, 'rgba(138, 43, 226, 0)');
                    
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(
                        boss.x + boss.width/2, 
                        boss.y + boss.height/2, 
                        150, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            if (player.animation) {
                ctx.save();
                if (!player.facingRight) {
                    ctx.scale(-1, 1);
                    if (player.transformed) {
                        ctx.drawImage(
                            player.animation, 
                            -player.x - player.knightWidth, 
                            player.y - player.knightOffsetY,
                            player.knightWidth, 
                            player.knightHeight
                        );
                    } else {
                        ctx.drawImage(
                            player.animation, 
                            -player.x - player.width, 
                            player.y, 
                            player.width, 
                            player.height
                        );
                    }
                } else {
                    if (player.transformed) {
                        ctx.drawImage(
                            player.animation, 
                            player.x, 
                            player.y - player.knightOffsetY,
                            player.knightWidth, 
                            player.knightHeight
                        );
                    } else {
                        ctx.drawImage(
                            player.animation, 
                            player.x, 
                            player.y, 
                            player.width, 
                            player.height
                        );
                    }
                }
                
                if (player.isDashing) {
                    const glow = ctx.createRadialGradient(
                        player.x + (player.transformed ? player.knightWidth/2 : player.width/2), 
                        player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2), 
                        0,
                        player.x + (player.transformed ? player.knightWidth/2 : player.width/2), 
                        player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2), 
                        100
                    );
                    glow.addColorStop(0, 'rgba(100, 200, 255, 0.8)');
                    glow.addColorStop(1, 'rgba(100, 200, 255, 0)');
                    
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(
                        player.x + (player.transformed ? player.knightWidth/2 : player.width/2), 
                        player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2), 
                        100, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                ctx.restore();
            }

            drawBossHealth();
            
            if (player.isDead && !player.transformed) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#9370db';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ВЫ ПОГИБЛИ', canvas.width / 2, canvas.height / 2);
                
                ctx.fillStyle = '#b0c4de';
                ctx.font = '24px Arial';
                ctx.fillText('Нажмите F5 для перезапуска', canvas.width / 2, canvas.height / 2 + 50);
                ctx.textAlign = 'left';
            }
        }

        // Инициализация
        createStars();
        updateHealthDisplay();
        
        setTimeout(() => {
            showNextDialog();
        }, 4000);
        
        gameLoop();
    </script>
</body>
</html>