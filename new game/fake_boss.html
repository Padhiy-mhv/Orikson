<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orikson — Логово Старшего Демона</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas { 
            display: block; 
            width: 100vw;
            height: 100vh;
        }
        .level-title {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6a00;
            font-size: 48px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff4500;
            opacity: 1;
            transition: opacity 2s;
            z-index: 100;
            text-align: center;
        }
        .level-subtitle {
            font-size: 24px;
            display: block;
            margin-top: 10px;
            color: #ff8c00;
            text-shadow: 0 0 5px #ff4500;
        }
        .last-chance-btn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #ff0000, #8b0000);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 200;
            display: none;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7);
            transition: all 0.3s ease;
        }
        .last-chance-btn:hover {
            background: linear-gradient(45deg, #ff3030, #a50000);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.9);
        }
        .glow-effect {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(180, 120, 255, 0.3) 0%, transparent 70%);
            filter: blur(30px);
            z-index: 5;
            display: none;
        }
        .explosion-effect {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.8) 0%, transparent 70%);
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        .boss-explosion {
            position: absolute;
            width: 600px;
            height: 600px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 100, 0, 0.9) 0%, rgba(255, 50, 0, 0.7) 50%, transparent 80%);
            z-index: 15;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none;
            box-shadow: 0 0 100px rgba(255, 100, 0, 0.8);
        }
        .fire-wave {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 150, 0, 0.7) 0%, transparent 70%);
            z-index: 14;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none;
        }
        .dialog-box {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            max-width: 700px;
            background: rgba(40, 10, 10, 0.9);
            border: 2px solid #ff4500;
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 16px;
            z-index: 100;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            min-height: 80px;
        }
        .dialog-text {
            margin-bottom: 10px;
            line-height: 1.4;
            min-height: 40px;
        }
        .dialog-name {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(255, 69, 0, 0.7);
        }
        .dialog-name.player {
            color: #ffffff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
        }
        .dialog-name.knight {
            color: #ff8c00;
            text-shadow: 0 0 5px rgba(255, 140, 0, 0.7);
        }
        .dialog-name.statue {
            color: #c0c0c0;
            text-shadow: 0 0 5px rgba(192, 192, 192, 0.7);
        }
        .next-btn {
            float: right;
            background: linear-gradient(45deg, #ff4500, #ff6347);
            border: none;
            color: white;
            padding: 6px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin-top: 5px;
        }
        .next-btn:hover {
            background: linear-gradient(45deg, #ff6347, #ff7f50);
            transform: scale(1.05);
        }
        .next-btn:active {
            transform: scale(0.95);
        }
        .typing-effect {
            border-right: 2px solid white;
            animation: blink 0.7s infinite;
        }
        .shield-effect {
            position: absolute;
            border-radius: 50%;
            background: rgba(100, 200, 255, 0.2);
            border: 2px solid rgba(100, 200, 255, 0.5);
            z-index: 5;
            display: none;
            pointer-events: none;
        }
        .boss-health-bar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(20, 10, 10, 0.7);
            border: 2px solid #ff0000;
            border-radius: 5px;
            z-index: 100;
        }
        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4500);
            border-radius: 3px;
            transition: width 0.3s;
        }
        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 3px black;
        }
        .portal-effect {
            position: fixed;
            width: 100px;
            height: 150px;
            border-radius: 10px;
            background: radial-gradient(circle, rgba(120, 50, 220, 0.7) 0%, transparent 70%);
            z-index: 20;
            display: none;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 30px rgba(120, 50, 220, 0.8);
        }
        
        /* Полоска здоровья игрока */
        .health-bar-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background: rgba(30, 10, 10, 0.7);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #ff0000;
        }
        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4500, #ff8c00);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
            pointer-events: none;
        }

        /* Новые стили для огненного шторма */
        .fire-storm-warning {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,50,0,0.3) 0%, transparent 70%);
            border: 2px dashed rgba(255,100,0,0.8);
            z-index: 15;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: pulse 1s infinite;
        }

        .fire-storm-pillar {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,100,0,0.8), rgba(255,50,0,0.3));
            box-shadow: 0 0 30px 10px rgba(255,50,0,0.5);
            z-index: 10;
            pointer-events: none;
            transform: translate(-50%, 100%);
            bottom: 0;
        }

        .fire-storm-aftermath {
            position: absolute;
            border-radius: 50%;
            background: rgba(255,100,0,0.2);
            z-index: 5;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.7; }
        }

        @keyframes pillar-rise {
            0% { transform: translate(-50%, 100%) scale(0.5, 0); opacity: 0; }
            20% { transform: translate(-50%, 100%) scale(1, 0.1); opacity: 0.5; }
            50% { transform: translate(-50%, 100%) scale(1, 1); opacity: 1; }
            80% { transform: translate(-50%, 100%) scale(1, 1); opacity: 1; }
            100% { transform: translate(-50%, 100%) scale(1, 0); opacity: 0; }
        }

        @keyframes blink {
            0%, 100% { border-color: transparent; }
            50% { border-color: white; }
        }

        @keyframes explosion-grow {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        @keyframes fire-wave {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="levelTitle" class="level-title">
        Логово Старшего Демона
        <span class="level-subtitle">Огненная Бездна</span>
    </div>
    <button id="lastChanceBtn" class="last-chance-btn">Последний шанс</button>
    <div id="playerGlow" class="glow-effect"></div>
    <div id="explosion" class="explosion-effect"></div>
    <div id="bossExplosion" class="boss-explosion"></div>
    <div id="fireWave" class="fire-wave"></div>
    <div id="shield" class="shield-effect"></div>
    <div id="portalEffect" class="portal-effect"></div>
    <div id="dialogBox" class="dialog-box">
        <div id="dialogName" class="dialog-name"></div>
        <div id="dialogText" class="dialog-text"></div>
        <button id="nextBtn" class="next-btn">Далее</button>
    </div>
    <div id="bossHealthBar" class="boss-health-bar" style="display: none;">
        <div id="bossHealthFill" class="boss-health-fill"></div>
        <div id="bossHealthText" class="boss-health-text"></div>
    </div>
    
    <!-- Полоска здоровья игрока -->
    <div id="healthBarContainer" class="health-bar-container">
        <div id="healthBar" class="health-bar"></div>
        <div id="healthText" class="health-text"></div>
    </div>

    <script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script>
    <script>
        // ===== СИСТЕМА СОХРАНЕНИЯ HP ===== //
        // Проверяем и инициализируем HP при загрузке
        function initializeHealthSystem() {
            // Получаем текущее значение HP из localStorage
            let currentHP = localStorage.getItem('currentHP');
            let lastChanceUsed = localStorage.getItem('lastChanceUsed');
            
            // Если HP нет или оно некорректно, устанавливаем стартовое значение 15
            if (currentHP === null || currentHP === undefined || isNaN(parseInt(currentHP))) {
                localStorage.setItem('currentHP', '15');
                localStorage.setItem('lastChanceUsed', 'false');
            } else {
                // Если HP меньше или равно 0, сбрасываем
                if (parseInt(currentHP) <= 0) {
                    localStorage.setItem('currentHP', '15');
                    localStorage.setItem('lastChanceUsed', 'false');
                }
            }
            
            // Инициализируем lastChanceUsed, если его нет
            if (lastChanceUsed === null || lastChanceUsed === undefined) {
                localStorage.setItem('lastChanceUsed', 'false');
            }
        }

        // Вызываем инициализацию при загрузке скрипта
        initializeHealthSystem();

        // Функция для обновления HP
        function updateHP(change) {
            let currentHP = parseInt(localStorage.getItem('currentHP'));
            currentHP += change;
            
            // Ограничиваем HP в пределах от 0 до максимального значения
            if (currentHP < 0) currentHP = 0;
            if (currentHP > 15) currentHP = 15;
            
            // Сохраняем новое значение
            localStorage.setItem('currentHP', currentHP.toString());
            
            // Обновляем отображение
            updateHealthDisplay();
            
            return currentHP;
        }

        // Функция для получения текущего HP
        function getCurrentHP() {
            return parseInt(localStorage.getItem('currentHP'));
        }

        // Функция для полного сброса HP
        function resetHP() {
            localStorage.setItem('currentHP', '15');
            localStorage.setItem('lastChanceUsed', 'false');
            updateHealthDisplay();
        }

        // Функция для обновления отображения здоровья
        function updateHealthDisplay() {
            const healthBar = document.getElementById('healthBar');
            const healthText = document.getElementById('healthText');
            const currentHP = player.health;
            const maxHP = player.maxHealth;
            
            // Рассчитываем процент здоровья
            const percent = (currentHP / maxHP) * 100;
            healthBar.style.width = `${percent}%`;
            
            // Обновляем текст в зависимости от формы игрока
            healthText.textContent = player.transformed ? 
                `HP: ${currentHP}/${maxHP} (Рыцарь)` : 
                `HP: ${currentHP}/${maxHP}`;
        }

        // ===== ОСНОВНЫЕ НАСТРОЙКИ ===== //
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelTitle = document.getElementById('levelTitle');
        const lastChanceBtn = document.getElementById('lastChanceBtn');
        const playerGlow = document.getElementById('playerGlow');
        const explosion = document.getElementById('explosion');
        const bossExplosion = document.getElementById('bossExplosion');
        const fireWave = document.getElementById('fireWave');
        const shield = document.getElementById('shield');
        const portalEffect = document.getElementById('portalEffect');
        const dialogBox = document.getElementById('dialogBox');
        const dialogName = document.getElementById('dialogName');
        const dialogText = document.getElementById('dialogText');
        const nextBtn = document.getElementById('nextBtn');
        const bossHealthBar = document.getElementById('bossHealthBar');
        const bossHealthFill = document.getElementById('bossHealthFill');
        const bossHealthText = document.getElementById('bossHealthText');
        
        // Показать название уровня на 5 секунд
        setTimeout(() => {
            levelTitle.style.opacity = '0';
            setTimeout(() => {
                levelTitle.style.display = 'none';
            }, 2000);
        }, 4000);
        
        // Получаем здоровье игрока из localStorage
        const initialHealth = getCurrentHP();
        
        // Огненный фон
        const backgroundImage = new Image();
        backgroundImage.src = 'assets/images/boss.png';
        
        // Текстура земли для огненной локации
        const groundTexture = new Image();
        groundTexture.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiM0MDAwMDAiLz48cGF0aCBkPSJNMjAsMjAgQzMwLDEwIDQwLDMwIDMwLDQwIiBzdHJva2U9IiM2MDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik0xMCwxMCBDMjAsMCAzMCwyMCAyMCwzMCIgc3Ryb2tlPSIjODAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiLz48L3N2Zz4=';
        
        // Текстура платформ для огненной локации
        const platformTexture = new Image();
        platformTexture.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDUwIDIwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iMjAiIGZpbGw9IiM2MDAwMDAiLz48cGF0aCBkPSJNMCwxMCBDMTUsNSAzMCwxNSA1MCwxMCIgc3Ryb2tlPSIjODAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiLz48L3N2Zz4=';

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            groundLevel = canvas.height * 0.8;
        }
        window.addEventListener('resize', resizeCanvas);
        
        let groundLevel;
        resizeCanvas();
        
        // ===== ПЕРСОНАЖ ===== //
        const player = {
            x: 100,
            y: groundLevel - 70,
            width: 50,
            height: 70,
            knightWidth: 120,
            knightHeight: 150,
            knightOffsetY: 30,
            velocityX: 0,
            velocityY: 0,
            facingRight: true,
            isJumping: false,
            isAttacking: false,
            attackCooldown: 0,
            health: initialHealth,
            maxHealth: 15,
            animation: null,
            animator: null,
            currentAnimation: 'idle',
            invincible: false,
            invincibleTimer: 0,
            onGround: false,
            isDead: false,
            deathTimer: 0,
            canTeleport: false,
            deathAnimationPlayed: false,
            transformed: false,
            transformationTimer: 0,
            attackRange: 70,
            knightAttackRange: 150,
            damage: 1,
            knightDamage: 3,
            jumpForce: 15,
            knightJumpForce: 14,
            speed: 5,
            knightSpeed: 4,
            currentPlatform: null,
            hasShieldAbility: false,
            isBlocking: false,
            blockCooldown: 0
        };

        // ===== БОСС - СТАРШИЙ ДЕМОН ===== //
        const boss = {
            x: canvas.width * 0.5,
            y: groundLevel - 215,
            width: 250,
            height: 220,
            speed: 2,
            direction: -1,
            health: 35,
            maxHealth: 35,
            minX: canvas.width * 0.4,
            maxX: canvas.width * 0.9,
            animation: null,
            attackAnimation: null,
            hurtAnimation: null,
            deathAnimation: null,
            animator: null,
            isAttacking: false,
            isHurt: false,
            isDead: false,
            attackCooldown: 0,
            damage: 3,
            attackRange: 100,
            attackYRange: 80,
            hurtTimer: 0,
            deathTimer: 0,
            idleTimer: 0,
            isIdle: false,
            phase: 1,
            lastPlatformSpawn: 0,
            platformSpawnCooldown: 10000,
            attackDelay: 400,
            isAttackConnected: false,
            fireStormCooldown: 1500,
            isChargingFireStorm: false,
            isCastingFireStorm: false,
            fireStormTargets: [],
            fireStormPillars: [],
            fireStormAftermaths: [],
            explosionTriggered: false
        };

        // ===== ПОРТАЛ ===== //
        const portal = {
            x: canvas.width - 120,
            y: groundLevel - 150,
            width: 100,
            height: 150,
            active: false,
            animation: null,
            animator: null,
            particles: []
        };

        // ===== АНИМАЦИИ ===== //
        const playerAnimations = { 
            idle: null, 
            walk: null, 
            jump: null,
            attack: null,
            hurt: null,
            death: null,
            knightIdle: null,
            knightWalk: null,
            knightAttack: null,
            knightJump: null,
            animators: {
                idle: null,
                walk: null,
                jump: null,
                attack: null,
                hurt: null,
                death: null,
                knightIdle: null,
                knightWalk: null,
                knightAttack: null,
                knightJump: null
            }
        };

        const bossAnimations = {
            idle: null,
            walk: null,
            attack: null,
            hurt: null,
            death: null,
            animators: {
                idle: null,
                walk: null,
                attack: null,
                hurt: null,
                death: null
            }
        };

        // ===== СТАТУЯ ===== //
        const statue = {
            x: canvas.width * 0.1,
            y: groundLevel - 200,
            width: 80,
            height: 200,
            animation: null,
            animator: null,
            active: true
        };

        // ===== ИСТОЧНИК ЖИЗНИ ===== //
        const healthSource = {
            x: 0,
            y: 0,
            width: 40,
            height: 60,
            animation: null,
            animator: null,
            active: false,
            used: false,
            timer: 0,
            duration: 7000
        };

        // ===== ВРЕМЕННЫЕ ПЛАТФОРМЫ ===== //
        const tempPlatforms = [];

        // ===== ОГНЕННЫЙ ШТОРМ ===== //
        const fireStorm = {
            warnings: [],
            pillars: [],
            aftermaths: [],
            damage: 2,
            radius: 100,
            aftermathRadius: 80,
            aftermathDuration: 3000
        };

        // ===== ДИАЛОГИ ===== //
        const initialDialogs = [
            { type: 'knight', text: 'Где-то тут обитает старший демон - босс этой территории.' },
            { type: 'knight', text: 'Скорее всего, именно из-за него сгорели деревья в Пурпурном лесу и появились младшие демоны.' },
            { type: 'player', text: 'Ого... должно быть он огромный! И здесь так жарко...' },
            { type: 'knight', text: 'Да, эта локация пропитана огненной магией. Будь осторожен!' },
            { type: 'statue', text: 'Путник... Я - древний страж леса фонарей так удж вышло что часть моего сознания попала в тебя через источник жизни. Позволь мне помочь тебе в этой битве.' },
            { type: 'statue', text: 'Для этой битвы тебе пригодится еще одна способность...' },
            { type: 'statue', text: 'Я дарую тебе защитный щит. Нажми Q, чтобы активировать его.' },
            { type: 'statue', text: 'Под щитом ты будешь получать только половину всего урона. Используй его мудро!' },
            { type: 'statue', text: 'А так же время от времени я буду создавать для тебя платформы с источником жизни используй его.' },
            { type: 'knight', text: 'Кажись у нас гости, готовься.' },
            { type: 'end-dialog' }
        ];

        const bossDeathDialogs = [
            { type: 'knight', text: 'Ты сделал это! Старший Демон повержен!' },
            { type: 'knight', text: 'Теперь лес сможет постепенно восстановиться...' },
            { type: 'player', text: 'Хотя...Стой нет, аура нежити не исчела в чем же причина?' },
            { type: 'knight', text: 'Нет..Не может быть, неужели это он..Но он же был запечатан много лет назад...' },
            { type: 'knight', text: 'Ладно друг мой, не время думать, видемо нас ждет еще одно испытание, скорее в портал!' },
            { type: 'end-dialog' }
        ];

        let currentDialogs = initialDialogs;
        let currentDialog = 0;
        let isTyping = false;
        let currentText = '';
        let currentIndex = 0;
        let typingSpeed = 20;
        let gameState = 'dialog';
        let bossActive = false;
        let lavaParticles = [];
        let time = 0;
        let bossDefeated = false;

        // ===== ФУНКЦИЯ ОГНЕННОГО ВЗРЫВА БОССА ===== //
        function triggerBossExplosion() {
            if (boss.explosionTriggered) return;
            
            boss.explosionTriggered = true;
            const explosionX = boss.x + boss.width/2;
            const explosionY = boss.y + boss.height/2;
            
            // Показываем основной взрыв
            bossExplosion.style.display = 'block';
            bossExplosion.style.left = `${explosionX}px`;
            bossExplosion.style.top = `${explosionY}px`;
            bossExplosion.style.opacity = '1';
            
            // Анимация основного взрыва
            bossExplosion.animate([
                { transform: 'translate(-50%, -50%) scale(0)', opacity: 0 },
                { transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
                { transform: 'translate(-50%, -50%) scale(1.5)', opacity: 0 }
            ], {
                duration: 1000,
                easing: 'ease-out'
            }).onfinish = () => {
                bossExplosion.style.display = 'none';
            };
            
            // Создаем волны огня
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const angle = (i * 45) * Math.PI / 180;
                    const distance = 100;
                    const waveX = explosionX + Math.cos(angle) * distance;
                    const waveY = explosionY + Math.sin(angle) * distance;
                    
                    fireWave.style.display = 'block';
                    fireWave.style.left = `${waveX}px`;
                    fireWave.style.top = `${waveY}px`;
                    fireWave.style.opacity = '1';
                    
                    fireWave.animate([
                        { transform: 'translate(-50%, -50%) scale(0.5)', opacity: 1 },
                        { transform: 'translate(-50%, -50%) scale(3)', opacity: 0 }
                    ], {
                        duration: 800,
                        easing: 'ease-out'
                    }).onfinish = () => {
                        fireWave.style.display = 'none';
                    };
                    
                    // Проверяем столкновение с игроком
                    setTimeout(() => {
                        const playerCenterX = player.x + (player.transformed ? player.knightWidth/2 : player.width/2);
                        const playerCenterY = player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2);
                        const dx = playerCenterX - waveX;
                        const dy = playerCenterY - waveY;
                        const distanceToWave = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distanceToWave < 150 && !player.invincible && !player.isDead) {
                            let damage = 5; // Сильный урон
                            
                            if (player.isBlocking) {
                                damage = Math.floor(damage * 0.5);
                                
                                ctx.save();
                                ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
                                ctx.beginPath();
                                ctx.arc(playerCenterX, playerCenterY, 60, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                            
                            player.health -= damage;
                            updateHP(-damage);
                            
                            if (player.health <= 0) {
                                playerDie();
                            } else {
                                // Сильный отброс игрока
                                player.velocityX = (playerCenterX < explosionX ? -1 : 1) * 15;
                                player.velocityY = -10;
                                playerHurt(boss);
                            }
                        }
                    }, 200);
                }, i * 100);
            }
            
            // Создаем частицы взрыва
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 200;
                    const particleX = explosionX + Math.cos(angle) * distance;
                    const particleY = explosionY + Math.sin(angle) * distance;
                    
                    const particle = document.createElement('div');
                    particle.className = 'fire-wave';
                    particle.style.width = '30px';
                    particle.style.height = '30px';
                    particle.style.left = `${particleX}px`;
                    particle.style.top = `${particleY}px`;
                    particle.style.opacity = '1';
                    document.body.appendChild(particle);
                    
                    particle.animate([
                        { transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
                        { transform: 'translate(-50%, -50%) scale(0.5)', opacity: 0 }
                    ], {
                        duration: 1000,
                        easing: 'ease-out'
                    }).onfinish = () => {
                        particle.remove();
                    };
                }, Math.random() * 500);
            }
        }

        function loadGIF(path, animationName, target) {
            const bufferCanvas = document.createElement('canvas');
            
            if (target === 'boss') {
                bufferCanvas.width = 180;
                bufferCanvas.height = 220;
            } else if (target === 'statue') {
                bufferCanvas.width = 80;
                bufferCanvas.height = 200;
            } else if (target === 'healthSource') {
                bufferCanvas.width = 40;
                bufferCanvas.height = 60;
            } else if (target === 'portal') {
                bufferCanvas.width = 100;
                bufferCanvas.height = 150;
            } else {
                bufferCanvas.width = 50;
                bufferCanvas.height = 70;
            }

            gifler(path).get((anim) => {
                anim.animateInCanvas(bufferCanvas);
                
                if (target === 'player') {
                    playerAnimations[animationName] = bufferCanvas;
                    playerAnimations.animators[animationName] = anim;
                    
                    if (animationName === 'idle' && !player.animation) {
                        player.animation = playerAnimations.idle;
                        player.animator = playerAnimations.animators.idle;
                        player.currentAnimation = 'idle';
                    }
                } else if (target === 'boss') {
                    bossAnimations[animationName] = bufferCanvas;
                    bossAnimations.animators[animationName] = anim;
                    
                    if (animationName === 'idle') {
                        boss.animation = bossAnimations.idle;
                        boss.animator = bossAnimations.animators.idle;
                    }
                } else if (target === 'statue') {
                    statue.animation = bufferCanvas;
                    statue.animator = anim;
                } else if (target === 'healthSource') {
                    healthSource.animation = bufferCanvas;
                    healthSource.animator = anim;
                } else if (target === 'portal') {
                    portal.animation = bufferCanvas;
                    portal.animator = anim;
                }
            });
        }

        // Загружаем анимации
        loadGIF('assets/images/player_idle.gif', 'idle', 'player');
        loadGIF('assets/images/player_walk.gif', 'walk', 'player');
        loadGIF('assets/images/player_jump.gif', 'jump', 'player');
        loadGIF('assets/images/player_attack.gif', 'attack', 'player');
        loadGIF('assets/images/player_hurt.gif', 'hurt', 'player');
        loadGIF('assets/images/player_death.gif', 'death', 'player');
        loadGIF('assets/images/knight_idle.gif', 'knightIdle', 'player');
        loadGIF('assets/images/knight_walk.gif', 'knightWalk', 'player');
        loadGIF('assets/images/knight_attack.gif', 'knightAttack', 'player');
        loadGIF('assets/images/knight_jump.gif', 'knightJump', 'player');

        loadGIF('assets/images/boss_idle.gif', 'idle', 'boss');
        loadGIF('assets/images/boss_walk.gif', 'walk', 'boss');
        loadGIF('assets/images/boss_attack.gif', 'attack', 'boss');
        loadGIF('assets/images/boss_hurt.gif', 'hurt', 'boss');
        loadGIF('assets/images/boss_death.gif', 'death', 'boss');

        loadGIF('assets/images/statue.gif', 'statue', 'statue');
        loadGIF('assets/images/health_source.gif', 'healthSource', 'healthSource');
        loadGIF('assets/images/portal.gif', 'portal', 'portal');

        // ===== ПЛАТФОРМЫ ===== //
        const platforms = [
            { x: 0, y: groundLevel, width: canvas.width, height: canvas.height - groundLevel, type: 'ground' },
            { x: 0, y: 0, width: 20, height: groundLevel, type: 'wall' },
            { x: canvas.width - 20, y: 0, width: 20, height: groundLevel, type: 'wall' }
        ];

        // Генерация частиц лавы
        function generateLavaParticles() {
            for (let i = 0; i < 100; i++) {
                lavaParticles.push({
                    x: Math.random() * canvas.width,
                    y: groundLevel + Math.random() * 50,
                    radius: Math.random() * 15 + 5,
                    speed: Math.random() * 2 + 1,
                    alpha: Math.random() * 0.5 + 0.3,
                    color: `hsl(${Math.random() * 20 + 10}, 100%, 50%)`
                });
            }
        }

        // Генерация частиц портала
        function generatePortalParticles() {
            for (let i = 0; i < 30; i++) {
                portal.particles.push({
                    x: portal.x + Math.random() * portal.width,
                    y: portal.y + Math.random() * portal.height,
                    radius: Math.random() * 10 + 5,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: (Math.random() - 0.5) * 2,
                    color: `hsl(${Math.random() * 60 + 270}, 100%, 50%)`,
                    alpha: Math.random() * 0.5 + 0.3,
                    life: Math.random() * 100 + 50
                });
            }
        }

        // Обновление частиц лавы
        function updateLavaParticles() {
            lavaParticles.forEach((p, i) => {
                p.y -= p.speed;
                p.alpha -= 0.01;
                
                if (p.alpha <= 0 || p.y < groundLevel - 100) {
                    lavaParticles[i] = {
                        x: Math.random() * canvas.width,
                        y: groundLevel + Math.random() * 10,
                        radius: Math.random() * 15 + 5,
                        speed: Math.random() * 2 + 1,
                        alpha: Math.random() * 0.5 + 0.3,
                        color: `hsl(${Math.random() * 20 + 10}, 100%, 50%)`
                    };
                }
            });
        }

        // Обновление частиц портала
        function updatePortalParticles() {
            if (!portal.active) return;
            
            portal.particles.forEach((p, i) => {
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                
                if (p.life <= 0 || 
                    p.x < portal.x || p.x > portal.x + portal.width ||
                    p.y < portal.y || p.y > portal.y + portal.height) {
                    
                    portal.particles[i] = {
                        x: portal.x + Math.random() * portal.width,
                        y: portal.y + Math.random() * portal.height,
                        radius: Math.random() * 10 + 5,
                        speedX: (Math.random() - 0.5) * 2,
                        speedY: (Math.random() - 0.5) * 2,
                        color: `hsl(${Math.random() * 60 + 270}, 100%, 50%)`,
                        alpha: Math.random() * 0.5 + 0.3,
                        life: Math.random() * 100 + 50
                    };
                }
            });
        }

        // Отрисовка частиц лавы
        function drawLavaParticles() {
            lavaParticles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // Отрисовка лавы
        function drawLava() {
            const lavaGradient = ctx.createLinearGradient(0, groundLevel, 0, groundLevel + 100);
            lavaGradient.addColorStop(0, '#ff4500');
            lavaGradient.addColorStop(0.5, '#ff0000');
            lavaGradient.addColorStop(1, '#800000');
            
            ctx.fillStyle = lavaGradient;
            ctx.fillRect(0, groundLevel, canvas.width, canvas.height - groundLevel);
            
            ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
            for (let i = 0; i < 20; i++) {
                const x = (time * 0.05 + i * 100) % (canvas.width + 200) - 100;
                const y = groundLevel + 20 + Math.sin(time * 0.02 + i) * 10;
                const radius = 15 + Math.sin(time * 0.03 + i * 2) * 5;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundLevel);
            
            for (let x = 0; x < canvas.width; x += 20) {
                const y = groundLevel + Math.sin(time * 0.05 + x * 0.1) * 10;
                ctx.lineTo(x, y);
            }
            
            ctx.stroke();
        }

        // Отрисовка платформ
        function drawPlatforms() {
            platforms.forEach(platform => {
                if (platform.type === 'ground' && groundTexture.complete) {
                    const pattern = ctx.createPattern(groundTexture, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                } 
                else if (platform.type === 'platform' && platformTexture.complete) {
                    const pattern = ctx.createPattern(platformTexture, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(platform.x, platform.y + platform.height, platform.width, 5);
                }
                else if (platform.type === 'wall') {
                    ctx.fillStyle = '#200000';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                }
            });
            
            tempPlatforms.forEach(platform => {
                if (platform.alpha <= 0) return;
                
                ctx.save();
                ctx.globalAlpha = platform.alpha;
                const pattern = ctx.createPattern(platformTexture, 'repeat');
                ctx.fillStyle = pattern;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(platform.x, platform.y + platform.height, platform.width, 3);
                ctx.restore();
            });
        }

        // Отрисовка статуи
        function drawStatue() {
            if (!statue.active || !statue.animation) return;
            
            ctx.save();
            ctx.drawImage(
                statue.animation,
                statue.x - statue.width/2,
                statue.y - statue.height,
                statue.width,
                statue.height
            );
            
            const lightX = statue.x;
            const lightY = statue.y - statue.height * 0.7;
            
            const gradient = ctx.createRadialGradient(
                lightX, lightY, 10,
                lightX, lightY, 100
            );
            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(lightX, lightY, 100, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Отрисовка источника жизни
        function drawHealthSource() {
            if (!healthSource.active || healthSource.used || !healthSource.animation) return;
            
            ctx.save();
            ctx.globalAlpha = healthSource.alpha;
            ctx.drawImage(
                healthSource.animation,
                healthSource.x - healthSource.width/2,
                healthSource.y - healthSource.height,
                healthSource.width,
                healthSource.height
            );
            
            const lightX = healthSource.x;
            const lightY = healthSource.y - healthSource.height * 0.7;
            
            const gradient = ctx.createRadialGradient(
                lightX, lightY, 10,
                lightX, lightY, 60
            );
            gradient.addColorStop(0, 'rgba(100, 255, 100, 0.3)');
            gradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(lightX, lightY, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            if (Math.abs(player.x - healthSource.x) < 50 && 
                Math.abs(player.y - healthSource.y) < 80 &&
                !healthSource.used && player.health < player.maxHealth) {
                
                healthSource.used = true;
                player.health = Math.min(player.health + 5, player.maxHealth);
                updateHP(5); // Обновляем сохраненное HP при лечении
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const particle = {
                            x: healthSource.x,
                            y: healthSource.y - healthSource.height,
                            radius: Math.random() * 5 + 2,
                            speedX: (Math.random() - 0.5) * 3,
                            speedY: -Math.random() * 3 - 1,
                            alpha: 1,
                            color: '#00ff00'
                        };
                        
                        const animateParticle = () => {
                            particle.x += particle.speedX;
                            particle.y += particle.speedY;
                            particle.alpha -= 0.02;
                            
                            if (particle.alpha > 0) {
                                ctx.save();
                                ctx.globalAlpha = particle.alpha;
                                ctx.fillStyle = particle.color;
                                ctx.beginPath();
                                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                                requestAnimationFrame(animateParticle);
                            }
                        };
                        
                        animateParticle();
                    }, i * 50);
                }
            }
        }

        // Отрисовка щита
        function drawShield() {
            if (!player.isBlocking || player.isDead) return;
            
            const shieldSize = player.transformed ? 100 : 80;
            shield.style.width = `${shieldSize}px`;
            shield.style.height = `${shieldSize}px`;
            shield.style.left = `${player.x + (player.transformed ? player.knightWidth/2 : player.width/2) - shieldSize/2}px`;
            shield.style.top = `${player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2) - shieldSize/2}px`;
            shield.style.display = 'block';
        }

        // Отрисовка здоровья босса
        function drawBossHealth() {
            if (!bossActive || boss.isDead) {
                bossHealthBar.style.display = 'none';
                return;
            }
            
            bossHealthBar.style.display = 'block';
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            bossHealthFill.style.width = `${healthPercent}%`;
            bossHealthText.textContent = `${boss.health}/${boss.maxHealth}`;
            
            if (healthPercent < 30) {
                bossHealthFill.style.background = 'linear-gradient(90deg, #ff0000, #800000)';
            } else if (healthPercent < 60) {
                bossHealthFill.style.background = 'linear-gradient(90deg, #ff4500, #ff0000)';
            } else {
                bossHealthFill.style.background = 'linear-gradient(90deg, #ff4500, #ff6347)';
            }
        }

        // Отрисовка портала
        function drawPortal() {
            if (!portal.active) return;
            
            if (portal.animation) {
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.drawImage(portal.animation, portal.x, portal.y, portal.width, portal.height);
                ctx.globalAlpha = 1.0;
                ctx.restore();
            } else {
                ctx.fillStyle = 'rgba(120, 50, 220, 0.7)';
                ctx.fillRect(portal.x, portal.y, portal.width, portal.height);
            }
            
            portal.particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            const portalCenterX = portal.x + portal.width / 2;
            const portalCenterY = portal.y + portal.height / 2;
            
            const glowGradient = ctx.createRadialGradient(
                portalCenterX, portalCenterY, 50,
                portalCenterX, portalCenterY, 150
            );
            glowGradient.addColorStop(0, 'rgba(120, 50, 220, 0.5)');
            glowGradient.addColorStop(1, 'rgba(120, 50, 220, 0)');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(portalCenterX, portalCenterY, 150, 0, Math.PI * 2);
            ctx.fill();
            
            if (player.x + (player.transformed ? player.knightWidth : player.width) > portal.x && 
                player.x < portal.x + portal.width &&
                player.y + (player.transformed ? player.knightHeight - player.knightOffsetY : player.height) > portal.y && 
                player.y < portal.y + portal.height) {
                
                portalEffect.style.display = 'block';
                portalEffect.style.left = `${player.x + (player.transformed ? player.knightWidth/2 : player.width/2)}px`;
                portalEffect.style.top = `${player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2)}px`;
                
                portalEffect.animate([
                    { transform: 'scale(0.5)', opacity: 0 },
                    { transform: 'scale(1)', opacity: 1 },
                    { transform: 'scale(1.5)', opacity: 0 }
                ], {
                    duration: 1000,
                    easing: 'ease-out'
                }).onfinish = () => {
                    portalEffect.style.display = 'none';
                    // Сохраняем текущее HP перед переходом
                    localStorage.setItem('currentHP', player.health.toString());
                    window.location.href = "final.html?health=" + player.health;
                };
            }
        }

        // Огненный шторм
        function startFireStorm() {
            if (boss.fireStormCooldown > 0 || boss.phase !== 2 || boss.isDead || boss.isHurt) return;
            
            boss.fireStormCooldown = 300;
            boss.isChargingFireStorm = true;
            boss.isIdle = true;
            boss.animation = bossAnimations.idle;
            boss.animator = bossAnimations.animators.idle;
            
            const numTargets = 3 + Math.floor(Math.random() * 3);
            boss.fireStormTargets = [];
            
            for (let i = 0; i < numTargets; i++) {
                const x = 100 + Math.random() * (canvas.width - 200);
                const y = groundLevel - 50 - Math.random() * 100;
                
                boss.fireStormTargets.push({
                    x: x,
                    y: y,
                    radius: boss.fireStormRadius,
                    timer: 0,
                    duration: 120
                });
                
                const warning = document.createElement('div');
                warning.className = 'fire-storm-warning';
                warning.style.width = `${boss.fireStormRadius * 2}px`;
                warning.style.height = `${boss.fireStormRadius * 2}px`;
                warning.style.left = `${x}px`;
                warning.style.top = `${y}px`;
                document.body.appendChild(warning);
                
                setTimeout(() => {
                    warning.remove();
                }, 2000);
            }
            
            setTimeout(() => {
                if (boss.isDead) return;
                
                boss.isChargingFireStorm = false;
                boss.isCastingFireStorm = true;
                
                boss.fireStormPillars = boss.fireStormTargets.map(target => {
                    return {
                        x: target.x,
                        y: target.y,
                        radius: boss.fireStormRadius,
                        timer: 0,
                        duration: 60
                    };
                });
                
                setTimeout(() => {
                    if (boss.isDead) return;
                    
                    boss.fireStormAftermaths = boss.fireStormTargets.map(target => {
                        return {
                            x: target.x,
                            y: target.y,
                            radius: boss.fireStormAftermathRadius,
                            timer: 0,
                            duration: boss.fireStormAftermathDuration
                        };
                    });
                    
                    boss.isCastingFireStorm = false;
                }, 1000);
            }, 2000);
        }

        function updateFireStorm() {
            if (boss.fireStormCooldown > 0) {
                boss.fireStormCooldown--;
            }
            
            if (boss.isCastingFireStorm && !player.invincible && !player.isDead) {
                const playerCenterX = player.x + (player.transformed ? player.knightWidth/2 : player.width/2);
                const playerCenterY = player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2);
                
                for (const pillar of boss.fireStormPillars) {
                    const dx = playerCenterX - pillar.x;
                    const dy = playerCenterY - pillar.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < pillar.radius + (player.transformed ? player.knightWidth/2 : player.width/2)) {
                        let damage = boss.fireStormDamage;
                        
                        if (player.isBlocking) {
                            damage = Math.floor(damage * 0.5);
                            
                            ctx.save();
                            ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
                            ctx.beginPath();
                            ctx.arc(playerCenterX, playerCenterY, 60, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                        
                        player.health -= damage;
                        updateHP(-damage); // Обновляем сохраненное HP при получении урона
                        
                        if (player.health <= 0) {
                            playerDie();
                        } else {
                            playerHurt(boss);
                        }
                        
                        break;
                    }
                }
            }
            
            if (boss.fireStormAftermaths.length > 0 && !player.invincible && !player.isDead) {
                const playerCenterX = player.x + (player.transformed ? player.knightWidth/2 : player.width/2);
                const playerCenterY = player.y + (player.transformed ? (player.knightHeight - player.knightOffsetY)/2 : player.height/2);
                
                for (const aftermath of boss.fireStormAftermaths) {
                    const dx = playerCenterX - aftermath.x;
                    const dy = playerCenterY - aftermath.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < aftermath.radius + (player.transformed ? player.knightWidth/2 : player.width/2)) {
                        if (player.onGround) {
                            let damage = Math.floor(boss.fireStormDamage * 0.3);
                            
                            if (player.isBlocking) {
                                damage = Math.floor(damage * 0.5);
                                
                                ctx.save();
                                ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                                ctx.beginPath();
                                ctx.arc(playerCenterX, playerCenterY, 60, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                            
                            player.health -= damage;
                            updateHP(-damage); // Обновляем сохраненное HP при получении урона
                            
                            if (player.health <= 0) {
                                playerDie();
                            } else {
                                playerHurt(boss);
                            }
                        }
                        
                        break;
                    }
                }
            }
            
            boss.fireStormAftermaths = boss.fireStormAftermaths.filter(aftermath => {
                aftermath.timer++;
                return aftermath.timer < aftermath.duration;
            });
        }

        function drawFireStorm() {
            for (const pillar of boss.fireStormPillars) {
                if (pillar.timer < pillar.duration) {
                    pillar.timer++;
                    
                    const progress = pillar.timer / pillar.duration;
                    const height = groundLevel - pillar.y;
                    const currentHeight = height * progress;
                    
                    ctx.save();
                    ctx.globalAlpha = 1 - progress * 0.5;
                    
                    const gradient = ctx.createRadialGradient(
                        pillar.x, groundLevel, pillar.radius * 0.5,
                        pillar.x, groundLevel, pillar.radius
                    );
                    gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(pillar.x, groundLevel, pillar.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    const pillarGradient = ctx.createLinearGradient(
                        pillar.x, groundLevel,
                        pillar.x, groundLevel - currentHeight
                    );
                    pillarGradient.addColorStop(0, 'rgba(255, 150, 0, 0.8)');
                    pillarGradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                    pillarGradient.addColorStop(1, 'rgba(255, 50, 0, 0.4)');
                    
                    ctx.fillStyle = pillarGradient;
                    ctx.beginPath();
                    ctx.moveTo(pillar.x - pillar.radius, groundLevel);
                    ctx.lineTo(pillar.x + pillar.radius, groundLevel);
                    ctx.lineTo(pillar.x + pillar.radius * 0.7, groundLevel - currentHeight);
                    ctx.lineTo(pillar.x - pillar.radius * 0.7, groundLevel - currentHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.6)';
                    ctx.beginPath();
                    ctx.arc(
                        pillar.x, 
                        groundLevel - currentHeight, 
                        pillar.radius * 0.5, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
            
            for (const aftermath of boss.fireStormAftermaths) {
                const progress = aftermath.timer / aftermath.duration;
                const alpha = 0.3 * (1 - progress);
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                const gradient = ctx.createRadialGradient(
                    aftermath.x, aftermath.y, 0,
                    aftermath.x, aftermath.y, aftermath.radius
                );
                gradient.addColorStop(0, 'rgba(255, 100, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(aftermath.x, aftermath.y, aftermath.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // Спавн временных платформ
        function spawnTempPlatforms() {
            if (!bossActive || boss.isDead || boss.isHurt) return;
            
            const now = Date.now();
            if (now - boss.lastPlatformSpawn < boss.platformSpawnCooldown) return;
            
            boss.lastPlatformSpawn = now;
            tempPlatforms.length = 0;
            healthSource.active = false;
            
            const side = Math.random() > 0.5 ? 'left' : 'right';
            let startX, direction;
            
            if (side === 'left') {
                startX = canvas.width * 0.1;
                direction = 1;
            } else {
                startX = canvas.width * 0.7;
                direction = -1;
            }
            
            const platformWidth = canvas.width * 0.15;
            const platformHeight = 20;
            const platformSpacing = canvas.width * 0.05;
            
            for (let i = 0; i < 3; i++) {
                const x = startX + (i * (platformWidth + platformSpacing)) * direction;
                const y = groundLevel - 150 - (i * 80);
                
                tempPlatforms.push({
                    x: x,
                    y: y,
                    width: platformWidth,
                    height: platformHeight,
                    alpha: 0,
                    targetAlpha: 1,
                    timer: 0,
                    duration: 1000
                });
                
                if (i === 2 && Math.random() > 0.5) {
                    healthSource.x = x + platformWidth/2;
                    healthSource.y = y;
                    healthSource.active = true;
                    healthSource.used = false;
                    healthSource.alpha = 0;
                    healthSource.timer = 0;
                }
            }
        }

        // Обновление временных платформ
        function updateTempPlatforms() {
            const now = Date.now();
            
            tempPlatforms.forEach(platform => {
                if (platform.timer < platform.duration) {
                    platform.timer += 16;
                    platform.alpha = platform.targetAlpha * (platform.timer / platform.duration);
                }
                
                if (now - boss.lastPlatformSpawn > boss.platformSpawnCooldown - 1000) {
                    platform.targetAlpha = 0;
                    platform.timer = Math.max(0, platform.timer - 16);
                    platform.alpha = platform.targetAlpha * (1 - (boss.platformSpawnCooldown - (now - boss.lastPlatformSpawn)) / 1000);
                }
            });
            
            if (healthSource.active) {
                if (healthSource.timer < healthSource.duration) {
                    healthSource.timer += 16;
                    
                    if (!healthSource.used) {
                        healthSource.alpha = Math.min(1, healthSource.timer / 500);
                    }
                }
                
                if (now - boss.lastPlatformSpawn > boss.platformSpawnCooldown - 1000) {
                    healthSource.alpha = Math.max(0, 1 - (boss.platformSpawnCooldown - (now - boss.lastPlatformSpawn)) / 1000);
                    
                    if (healthSource.alpha <= 0) {
                        healthSource.active = false;
                    }
                }
            }
            
            if (tempPlatforms.length > 0 && tempPlatforms[0].alpha <= 0) {
                tempPlatforms.shift();
            }
        }

        // Обновление босса
        function updateBoss() {
            if (boss.isDead) {
                boss.deathTimer--;
                if (boss.deathTimer <= 0 && !bossDefeated) {
                    bossDefeated = true;
                    currentDialogs = bossDeathDialogs;
                    currentDialog = 0;
                    gameState = 'dialog';
                    showNextDialog();
                }
                return;
            } else if (boss.health <= 0) {
                boss.isDead = true;
                boss.deathTimer = 120;
                boss.animation = bossAnimations.death;
                boss.animator = bossAnimations.animators.death;
                return;
            }

            // Проверяем, нужно ли активировать взрыв
            if (boss.health <= 3 && !boss.explosionTriggered) {
                triggerBossExplosion();
            }

            if (boss.isHurt) {
                boss.hurtTimer--;
                if (boss.hurtTimer <= 0) {
                    boss.isHurt = false;
                    boss.animation = bossAnimations.walk;
                    boss.animator = bossAnimations.animators.walk;
                }
            }

            if (boss.attackCooldown > 0) {
                boss.attackCooldown--;
            }

            if (boss.isIdle) {
                boss.idleTimer--;
                if (boss.idleTimer <= 0) {
                    boss.isIdle = false;
                    boss.animation = bossAnimations.walk;
                    boss.animator = bossAnimations.animators.walk;
                }
            } else if (Math.random() < 0.005 && !boss.isAttacking && !boss.isHurt) {
                boss.isIdle = true;
                boss.idleTimer = Math.random() * 60 + 30;
                boss.animation = bossAnimations.idle;
                boss.animator = bossAnimations.animators.idle;
            }

            if (!boss.isIdle && !boss.isAttacking && !boss.isHurt && !boss.isDead) {
                boss.x += boss.speed * boss.direction;
                
                if (boss.x <= boss.minX || boss.x + boss.width >= boss.maxX) {
                    boss.direction *= -1;
                }
                
                if (boss.health < boss.maxHealth * 0.5) {
                    boss.phase = 2;
                    boss.platformSpawnCooldown = 7000;
                    boss.fireStormRadius = 100;
                    boss.fireStormAftermathRadius = 80;
                    boss.fireStormAftermathDuration = 3000;
                    boss.fireStormDamage = 2;
                    
                    if (Math.random() < 0.1 && boss.fireStormCooldown <= 0) {
                        startFireStorm();
                    }
                }
                
                spawnTempPlatforms();
            }

            checkBossAttack();
            updateFireStorm();
        }

        // Проверка атаки босса
        function checkBossAttack() {
            if (player.isDead || player.invincible) return;
            
            const distanceX = Math.abs((player.x + player.width/2) - (boss.x + boss.width/2));
            const distanceY = Math.abs((player.y + player.height/2) - (boss.y + boss.height/2));
            const isInRangeX = distanceX < boss.attackRange;
            const isInRangeY = distanceY < boss.attackYRange;
            
            const isFacingPlayer = (boss.direction < 0 && player.x < boss.x) || 
                                 (boss.direction > 0 && player.x > boss.x);
            
            if (isInRangeX && isInRangeY && isFacingPlayer && 
                boss.attackCooldown <= 0 && !boss.isHurt && !boss.isDead) {
                
                boss.isAttacking = true;
                boss.isAttackConnected = false;
                boss.animation = bossAnimations.attack;
                boss.animator = bossAnimations.animators.attack;
                boss.attackCooldown = 120;
                
                setTimeout(() => {
                    if (isInRangeX && isInRangeY && !player.invincible && !player.isDead && !boss.isAttackConnected) {
                        let damage = boss.damage;
                        
                        if (player.isBlocking) {
                            damage = Math.floor(damage * 0.5);
                            
                            ctx.save();
                            ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
                            ctx.beginPath();
                            ctx.arc(
                                player.x + player.width/2, 
                                player.y + player.height/2, 
                                60, 
                                0, 
                                Math.PI * 2
                            );
                            ctx.fill();
                            ctx.restore();
                        }
                        
                        player.health -= damage;
                        updateHP(-damage); // Обновляем сохраненное HP при получении урона
                        boss.isAttackConnected = true;
                        
                        if (player.health <= 0) {
                            playerDie();
                        } else {
                            playerHurt(boss);
                        }
                    }
                }, boss.attackDelay);
                
                setTimeout(() => {
                    boss.isAttacking = false;
                    if (!boss.isHurt && !boss.isDead) {
                        boss.animation = bossAnimations.walk;
                        boss.animator = bossAnimations.animators.walk;
                    }
                }, 800);
            }
        }

        // Физика игрока
        function updatePlayerPhysics() {
            if (player.isDead && !player.transformed) return;

            if (player.attackCooldown > 0) {
                player.attackCooldown--;
            }

            if (player.blockCooldown > 0) {
                player.blockCooldown--;
            }

            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                    if (!player.isJumping && !player.isAttacking && !player.isBlocking) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                }
            }

            if (player.transformed) {
                player.transformationTimer--;
                if (player.transformationTimer <= 0) {
                    endTransformation();
                }
            }

            player.velocityY += 0.7;
            player.y += player.velocityY;
            player.onGround = false;
            player.currentPlatform = null;

            platforms.forEach(platform => {
                const playerBottom = player.transformed ? 
                    (player.y + player.knightHeight - player.knightOffsetY) : 
                    (player.y + player.height);
                
                const playerWidth = player.transformed ? player.knightWidth : player.width;
                const playerHeight = player.transformed ? player.knightHeight : player.height;
                
                if (
                    playerBottom >= platform.y &&
                    playerBottom <= platform.y + 20 &&
                    player.x + playerWidth > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.velocityY >= 0
                ) {
                    player.y = platform.y - (player.transformed ? player.knightHeight - player.knightOffsetY : player.height);
                    player.velocityY = 0;
                    player.isJumping = false;
                    player.onGround = true;
                    player.currentPlatform = platform;
                    
                    if (!player.isAttacking && !player.invincible && !player.isDead && !player.isBlocking) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                }
            });
            
            tempPlatforms.forEach(platform => {
                if (platform.alpha <= 0) return;
                
                const playerBottom = player.transformed ? 
                    (player.y + player.knightHeight - player.knightOffsetY) : 
                    (player.y + player.height);
                
                const playerWidth = player.transformed ? player.knightWidth : player.width;
                const playerHeight = player.transformed ? player.knightHeight : player.height;
                
                if (
                    playerBottom >= platform.y &&
                    playerBottom <= platform.y + 20 &&
                    player.x + playerWidth > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.velocityY >= 0
                ) {
                    player.y = platform.y - (player.transformed ? player.knightHeight - player.knightOffsetY : player.height);
                    player.velocityY = 0;
                    player.isJumping = false;
                    player.onGround = true;
                    player.currentPlatform = platform;
                    
                    if (!player.isAttacking && !player.invincible && !player.isDead && !player.isBlocking) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                }
            });

            if (!player.isAttacking && !player.invincible && !player.isDead && !player.isBlocking) {
                const speed = player.transformed ? player.knightSpeed : player.speed;
                
                if (keys['a'] || keys['arrowleft']) {
                    player.velocityX = -speed;
                    player.facingRight = false;
                    if (player.onGround) {
                        player.currentAnimation = player.transformed ? 'knightWalk' : 'walk';
                        player.animation = player.transformed ? playerAnimations.knightWalk : playerAnimations.walk;
                        player.animator = player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk;
                    }
                } else if (keys['d'] || keys['arrowright']) {
                    player.velocityX = speed;
                    player.facingRight = true;
                    if (player.onGround) {
                        player.currentAnimation = player.transformed ? 'knightWalk' : 'walk';
                        player.animation = player.transformed ? playerAnimations.knightWalk : playerAnimations.walk;
                        player.animator = player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk;
                    }
                } else {
                    player.velocityX = 0;
                    if (player.onGround && !player.isJumping) {
                        player.currentAnimation = player.transformed ? 'knightIdle' : 'idle';
                        player.animation = player.transformed ? playerAnimations.knightIdle : playerAnimations.idle;
                        player.animator = player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle;
                    }
                }
            } else {
                player.velocityX *= 0.9;
            }

            player.x += player.velocityX;

            const playerWidth = player.transformed ? player.knightWidth : player.width;
            if (player.x < 20) player.x = 20;
            if (player.x + playerWidth > canvas.width - 20) player.x = canvas.width - 20 - playerWidth;
        }

        // Управление
        const keys = {};
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            if (player.isDead && !player.transformed) return;
            
            if ((key === 'w' || key === 'arrowup') && !player.isJumping && player.onGround) {
                player.isJumping = true;
                const jumpForce = player.transformed ? player.knightJumpForce : player.jumpForce;
                player.velocityY = -jumpForce;
                player.currentAnimation = player.transformed ? 'knightJump' : 'jump';
                player.animation = player.transformed ? playerAnimations.knightJump : playerAnimations.jump;
                player.animator = player.transformed ? playerAnimations.animators.knightJump : playerAnimations.animators.jump;
            }
            
            if (key === 'f' && !player.isAttacking && player.attackCooldown <= 0 && !player.isBlocking) {
                player.isAttacking = true;
                player.currentAnimation = player.transformed ? 'knightAttack' : 'attack';
                player.animation = player.transformed ? playerAnimations.knightAttack : playerAnimations.attack;
                player.animator = player.transformed ? playerAnimations.animators.knightAttack : playerAnimations.animators.attack;
                player.attackCooldown = player.transformed ? 40 : 30;
                
                setTimeout(() => {
                    player.isAttacking = false;
                    if (!player.isJumping && !player.isDead && !player.isBlocking) {
                        player.currentAnimation = player.velocityX !== 0 ? 
                            (player.transformed ? 'knightWalk' : 'walk') : 
                            (player.transformed ? 'knightIdle' : 'idle');
                        player.animation = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.knightWalk : playerAnimations.walk) : 
                            (player.transformed ? playerAnimations.knightIdle : playerAnimations.idle);
                        player.animator = player.velocityX !== 0 ? 
                            (player.transformed ? playerAnimations.animators.knightWalk : playerAnimations.animators.walk) : 
                            (player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.idle);
                    }
                }, player.transformed ? 600 : 500);
                
                setTimeout(() => {
                    checkPlayerAttack();
                }, player.transformed ? 300 : 200);
            }
            
            if (key === 'q' && player.hasShieldAbility && !player.isAttacking && player.blockCooldown <= 0) {
                player.isBlocking = true;
                drawShield();
            }

            if ((key === 'enter' || key === ' ') && gameState === 'dialog') {
                handleNextDialog();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
            
            if (key === 'q' && player.isBlocking) {
                player.isBlocking = false;
                shield.style.display = 'none';
                player.blockCooldown = 30;
            }
        });

        // Атака игрока
        function checkPlayerAttack() {
            if (!player.isAttacking || player.isDead) return;

            const attackRange = player.transformed ? player.knightAttackRange : player.attackRange;
            const damage = player.transformed ? player.knightDamage : player.damage;
            
            if (bossActive && !boss.isDead) {
                const playerAttackX = player.facingRight ? 
                    player.x + (player.transformed ? player.knightWidth : player.width) : 
                    player.x;
                    
                const bossX = boss.x + boss.width/2;
                const distanceX = Math.abs(playerAttackX - bossX);
                
                const playerY = player.transformed ? 
                    player.y - player.knightOffsetY + player.knightHeight/2 : 
                    player.y + player.height/2;
                    
                const bossY = boss.y + boss.height/2;
                const distanceY = Math.abs(playerY - bossY);
                
                const isInRangeX = distanceX < attackRange;
                const isInRangeY = distanceY < 100;
                
                if (isInRangeX && isInRangeY) {
                    boss.health -= damage;
                    
                    if (boss.health <= 0) {
                        boss.isDead = true;
                        boss.deathTimer = 120;
                        boss.animation = bossAnimations.death;
                        boss.animator = bossAnimations.animators.death;
                    } else {
                        boss.isHurt = true;
                        boss.hurtTimer = 30;
                        boss.animation = bossAnimations.hurt;
                        boss.animator = bossAnimations.animators.hurt;
                        
                        boss.velocityX = (player.facingRight ? 1 : -1) * 5;
                    }
                }
            }
        }

        function playerHurt(enemy) {
            player.invincible = true;
            player.invincibleTimer = 60;
            player.currentAnimation = player.transformed ? 'knightIdle' : 'hurt';
            player.animation = player.transformed ? playerAnimations.knightIdle : playerAnimations.hurt;
            player.animator = player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.hurt;
            
            player.velocityX = (player.x < enemy.x ? -1 : 1) * (player.transformed ? 6 : 8);
            player.velocityY = player.transformed ? -4 : -6;
        }

        function playerDie() {
            player.isDead = true;
            player.currentAnimation = player.transformed ? 'knightIdle' : 'death';
            player.animation = player.transformed ? playerAnimations.knightIdle : playerAnimations.death;
            player.animator = player.transformed ? playerAnimations.animators.knightIdle : playerAnimations.animators.death;
            
            // Проверяем, использован ли уже последний шанс
            const lastChanceUsed = localStorage.getItem('lastChanceUsed') === 'true';
            
            if (!lastChanceUsed) {
                setTimeout(() => {
                    showLastChance();
                }, 2000);
            }
        }

        function showLastChance() {
            lastChanceBtn.style.display = 'block';
        }

        lastChanceBtn.addEventListener('click', () => {
            lastChanceBtn.style.display = 'none';
            localStorage.setItem('lastChanceUsed', 'true');
            transformToKnight();
        });

        function transformToKnight() {
            player.isDead = false;
            player.transformed = true;
            player.transformationTimer = 240;
            player.health = Math.floor(player.maxHealth / 2);
            updateHP(Math.floor(player.maxHealth / 2) - player.health);
            player.invincible = true;
            
            if (player.currentPlatform) {
                player.y = player.currentPlatform.y - (player.knightHeight - player.knightOffsetY);
            } else if (player.onGround) {
                player.y = groundLevel - (player.knightHeight - player.knightOffsetY);
            }
            
            // Эффект трансформации
            playerGlow.style.display = 'block';
            playerGlow.style.left = `${player.x - 150}px`;
            playerGlow.style.top = `${player.y - 150}px`;
            
            const glowAnimation = playerGlow.animate(
                [
                    { transform: 'scale(1)', opacity: 0.7 },
                    { transform: 'scale(1.2)', opacity: 0.3 },
                    { transform: 'scale(1)', opacity: 0.7 }
                ],
                {
                    duration: 1000,
                    iterations: Infinity
                }
            );
            
            setTimeout(() => {
                glowAnimation.cancel();
                playerGlow.style.display = 'none';
            }, 1000);
            
            // Эффект взрыва (без урона врагам)
            explosion.style.display = 'block';
            explosion.style.left = `${player.x + (player.transformed ? player.knightWidth/2 : player.width/2)}px`;
            explosion.style.top = `${player.y + (player.transformed ? player.knightHeight/2 : player.height/2)}px`;
            explosion.style.opacity = '0.8';
            
            explosion.animate(
                [
                    { transform: 'scale(0.5)', opacity: 0 },
                    { transform: 'scale(1)', opacity: 0.8 },
                    { transform: 'scale(1.5)', opacity: 0 }
                ],
                {
                    duration: 1000,
                    easing: 'ease-out'
                }
            ).onfinish = () => {
                explosion.style.display = 'none';
            };
            
            // Устанавливаем анимацию рыцаря
            player.currentAnimation = 'knightIdle';
            player.animation = playerAnimations.knightIdle;
            player.animator = playerAnimations.animators.knightIdle;
            
            // Обновляем отображение здоровья
            updateHealthDisplay();
        }

        function endTransformation() {
            player.transformed = false;
            player.invincible = false;
            
            // Фиксим позицию после трансформации
            if (player.currentPlatform) {
                player.y = player.currentPlatform.y - player.height;
            } else if (player.onGround) {
                player.y = groundLevel - player.height;
            }
            
            // Эффект взрыва при окончании трансформации
            explosion.style.display = 'block';
            explosion.style.left = `${player.x + player.width/2}px`;
            explosion.style.top = `${player.y + player.height/2}px`;
            explosion.style.opacity = '0.8';
            
            explosion.animate(
                [
                    { transform: 'scale(0.5)', opacity: 0 },
                    { transform: 'scale(1)', opacity: 0.8 },
                    { transform: 'scale(1.5)', opacity: 0 }
                ],
                {
                    duration: 1000,
                    easing: 'ease-out'
                }
            ).onfinish = () => {
                explosion.style.display = 'none';
            };
            
            // Возвращаем обычную анимацию
            player.currentAnimation = 'idle';
            player.animation = playerAnimations.idle;
            player.animator = playerAnimations.animators.idle;
            
            // Обновляем отображение здоровья
            updateHealthDisplay();
            
            // Если здоровье упало до нуля после трансформации
            if (player.health <= 0) {
                player.isDead = true;
                player.currentAnimation = 'death';
                player.animation = playerAnimations.death;
                player.animator = playerAnimations.animators.death;
            }
        }

        // Диалоги
        function typeText() {
            if (currentIndex < currentText.length) {
                dialogText.innerHTML = currentText.substring(0, currentIndex + 1) + '<span class="typing-effect"></span>';
                currentIndex++;
                setTimeout(typeText, typingSpeed);
            } else {
                dialogText.innerHTML = currentText;
                isTyping = false;
                nextBtn.style.display = 'block';
            }
        }

        function showNextDialog() {
            if (currentDialog >= currentDialogs.length) {
                endDialogSequence();
                return;
            }
            
            const dialog = currentDialogs[currentDialog];
            
            if (dialog.type === 'end-dialog') {
                endDialogSequence();
                return;
            }
            
            dialogBox.style.display = 'block';
            nextBtn.style.display = 'none';
            
            if (dialog.type === 'player') {
                dialogName.textContent = 'Игрок';
                dialogName.className = 'dialog-name player';
                dialogText.style.color = '#ffffff';
            } 
            else if (dialog.type === 'knight') {
                dialogName.textContent = 'Рыцарь';
                dialogName.className = 'dialog-name knight';
                dialogText.style.color = '#ff8c00';
            }
            else if (dialog.type === 'statue') {
                dialogName.textContent = 'Древний Страж';
                dialogName.className = 'dialog-name statue';
                dialogText.style.color = '#c0c0c0';
            }
            
            currentText = dialog.text;
            currentIndex = 0;
            isTyping = true;
            typeText();
        }

        function handleNextDialog() {
            if (isTyping) {
                currentIndex = currentText.length;
                dialogText.innerHTML = currentText;
                isTyping = false;
                nextBtn.style.display = 'block';
            } else {
                currentDialog++;
                showNextDialog();
            }
        }

        nextBtn.addEventListener('click', handleNextDialog);

        function endDialogSequence() {
            dialogBox.style.display = 'none';
            gameState = 'gameplay';
            
            if (currentDialogs === initialDialogs) {
                bossActive = true;
                player.hasShieldAbility = true;
            } else if (currentDialogs === bossDeathDialogs) {
                // Активируем портал только один раз после победы над боссом
                if (!portal.active) {
                    portal.active = true;
                    generatePortalParticles();
                }
            }
        }

        // Основной игровой цикл
        function gameLoop() {
            time += 16;
            
            if (gameState !== 'dialog') {
                updatePlayerPhysics();
                updateTempPlatforms();
                
                if (bossActive) {
                    updateBoss();
                }
                
                updateLavaParticles();
                updatePortalParticles();
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (backgroundImage.complete) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                bgGradient.addColorStop(0, '#300000');
                bgGradient.addColorStop(1, '#800000');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            drawLava();
            drawLavaParticles();
            drawPlatforms();
            drawStatue();
            drawHealthSource();
            
            if (bossActive && boss.animation) {
                ctx.save();
                if (boss.x > player.x) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(boss.animation, -boss.x - boss.width, boss.y, boss.width, boss.height);
                } else {
                    ctx.drawImage(boss.animation, boss.x, boss.y, boss.width, boss.height);
                }
                ctx.restore();
            }
            
            if (boss.phase === 2) {
                drawFireStorm();
            }
            
            drawPortal();
            
            if (player.animation) {
                ctx.save();
                if (!player.facingRight) {
                    ctx.scale(-1, 1);
                    if (player.transformed) {
                        ctx.drawImage(
                            player.animation, 
                            -player.x - player.knightWidth, 
                            player.y - player.knightOffsetY,
                            player.knightWidth, 
                            player.knightHeight
                        );
                    } else {
                        ctx.drawImage(
                            player.animation, 
                            -player.x - player.width, 
                            player.y, 
                            player.width, 
                            player.height
                        );
                    }
                } else {
                    if (player.transformed) {
                        ctx.drawImage(
                            player.animation, 
                            player.x, 
                            player.y - player.knightOffsetY,
                            player.knightWidth, 
                            player.knightHeight
                        );
                    } else {
                        ctx.drawImage(
                            player.animation, 
                            player.x, 
                            player.y, 
                            player.width, 
                            player.height
                        );
                    }
                }
                ctx.restore();
            }

            drawBossHealth();
            
            if (player.isDead && !player.transformed) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ff4500';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ВЫ ПОГИБЛИ', canvas.width / 2, canvas.height / 2);
                
                ctx.fillStyle = '#ffa07a';
                ctx.font = '24px Arial';
                ctx.fillText('Нажмите F5 для перезапуска', canvas.width / 2, canvas.height / 2 + 50);
                ctx.textAlign = 'left';
            }
        }

        // Инициализация
        generateLavaParticles();
        
        // Показываем начальные диалоги
        setTimeout(() => {
            showNextDialog();
        }, 4000);
        
        gameLoop();
    </script>
</body>
</html>